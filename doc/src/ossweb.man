[manpage_begin OSSWEB n 2.0]
[copyright {Vlad Seryakov vseryakov@gmail.com December 2006}]
[moddesc {OSSWEB Framework}]

[titledesc {Framework for developers}]

[description]
Web development framework based on [uri http://tcl.tk Tcl] language and
[uri http://http://sourceforge.net/projects/naviserver/ Naviserver]
application server.


[section History]

Why another Web application framework, how many exist already,
can't you just pick one and use it? This is a good question and as i
see how many frameworks exist today, not an easy one. Back at 2000 when
i was building high performance http proxy, i needed small scripting
language to embed into my server. At that time i liked Python and did
all scripting tasks using it but the server i was working on had to
be multi-threaded and Python did not support threads very well. It
has one master lock which allows only one thread to execute Python
code, so multiple interpreters in one address space will be serialize
one after another which gives not very good performance if you need to
serve hundreds or thousands requests. Perl i never liked, PHP was for
Apache only, the only 2 languages i found were Lua and Tcl. For some
reason i do not remember now i chose Tcl. It was very easy to embed, C
API is very well documented and simple. So in no time my proxy server
was able to call small scripts in multiple threads and it gave a lot of
additional functionality because some things were much easier to cod
ein scripting language than in C.

[para]

Then another big project came in and i had to choose Web application
platform but the trick was, it was supposed to be really big system,
and Web was only part of it. The system had to support job scheduling,
different communication protocols, background tasks, different
databases and other non-Web related stuff and at the same time it
should be accessible and configured only through Web interface. I
forgot to mention that open-source tools were preferable and we were
not Microsoft shop, but we had some software running on Windows we
needed to connect to. Having experience with Apache, PHP and Java i was
still looking when i found at that time active web site of the company
called ArsDigita. The forums on that site were so interesting and
useful so i digged up deeper and found execelent book by Philip
Greenspun, [emph {Philip and Alex's Guide to Web Publishing}] available at
[uri http://philip.greenspun.com/panda/]. I used Tcl by that time, so i was
basically hooked. I installed AOLserver and started playing with it to
see if this is what i need for my new project. It turned out that
combination of AOLserver and some parts of ArsDigita open-source
software called ACS were almost perfectly fit but what was more
important, the platform was giving almost unlimited posibilities as in
Web space and also in other backend or server architecture related
domains. The AOLserver's API, Tcl and C was so powerfull and rich,
extending it was so easy, after almost 2 years of development and
maintaining the whole system was built just using AOLServer, Tcl. C was
used only for specific modules like SNMP, ICMP protocols, database
driver and other low-level stuff. During the development, the system
grew from pieces of former ACS system into completely different Web
application framework with its own security model, API and data model.
By the time ArsDigita disappeared we no longer actually needed it
because we were completely independent from any outside companies, all
tools we used were open-sourced.

[section {Why Naviserver?}]

We were using [uri http://ww.aolserver.com AOLserver] since 2001, started
with version 3.3. After several years i collected a bunch of patches and
modules that i was trying to keep up-to-date with new versions of AOLserver.
I tried to submit my patches, some have been accepted, some not but after some time
it was obvious that AOLserver is intended to be Web server only while i
wanted it to be more versatile application platform where Web is just
one of the features. I wanted the server to supported different
protocols, not just HTTP, more flexible API, more modules and
functions. I am not saying i was right and others were wrong, but i saw
the potential of the server to be much bigger than just a
Web server and not embracing it was very frustrating for me. So,
Naviserver was born as a fork of AOLserver version 4.0.10. Since then a
lot of stuff have been added and changed in Naviserver that those two
servers cannot be simply switched, Naviserver has much larger API set
which is not available in AOLserver.

[para]

So, enough history and explanations, let's get closer to the
OSSWEB/Naviserver framework and how they are bound to each other.

[section Concepts]

[subsection Components]

Let's start from the lowest level up to the top. The programming
language is [uri http://www.tcl.tk/doc/ Tcl]. Arguably it is not
the best language but it is very old and still being actively developed,
it is very stable, supports threads natively, has good library of useful
applications and modules.
And it is so simple it is nothing to learn actually, there is no
syntax, but the specific syntax can be built using Tcl and we are using
this feature. Created as a glue language it actually grew up into
general purpose programming language. It is not popular as Java, Perl,
Python or Ruby but still has large community and used in many
applications. On other hand, popularity never bothered me much, if i
like the language, it does the job i do not care how many people using
it and i am not going to switch just because it does not make headlines
anymore.

So, next level is Naviserver, Tcl is embedded into it very deeply, the
language is part of the core, that's why Naviserver is very high
performance server even with scripting language, there is no overhead,
Tcl interpreters are used when they are needed, then they are put back
into the pools of availabld interpreters, so other threads can re-use
existing interpreter at any time. Also, Tcl in Naviserver is the
developement language, more than 200 Tcl functions are available for a
developer ranging from accessing internal server state to inter-thread
communications and Web page filters.

[para]
The biggest difference between Naviserver and other Web server like
Apache or lighttpd or other pure Web server that it is capable of
not just serving Web page but provide complete server infrastructure
that can be used to build more complex server applications. For example,
if some actions needs to be run every once in a while, there is internal
scheduler than can run Tcl scripts the same way as cron does. Every
script can access database using the same API, all additional library
functions are available to every thread the same way as system calls
from glibc are avaialbel to all user programs. Socket callbacks and
client functions, access to file system and database, local cache
with expiration for any kind of data, shared variables with automatic
locking and more can be used to develop backend applications in addition
to Web applications.

[para]

So, let's start with describing how Naviserver processes HTTP request.
There are many ways to build request processors, i will describe how
OSSWEB framework does it. Naviserver is getting much better
documentation now, so many answers on specific programming issues can
be found there.

[para]

Naviserver's HTTP driver is listening for example on port 80. It can
accept and process multiple connections at once, it uses async I/O,
therefore is able to accept and process many connections without
spawning threads. Once a connection is accepted and HTTP request line
and headers are read and parsed, driver passes this request structure
to first available connection thread. There are can be different
thread pools defined with minimum and maximum parameters, which
prevents from overloadig the system with too many threads and at the
same time keeps some number of idle threads ready to process new
requests. That connection thread will be responsible now what to do with
the request and for returning valid HTTP response, driver thread will
continue to accept new connections and reading HTTP requests from other
sockets.

[para]

In Naviserver there are different methods how to serve HTTP requests:

[list_begin itemized]

[item] register Tcl proc for particular methdod and URL

[item] register filter for particular method or URL

[item] let the server resolve request URL into file and serve static file
back to the browser (this method is always registered and is called at
the end if nobody handled request)

[list_end]

So at the minimum, just installed Naviserver can serve static HTML
files as Apache or other Web servers.

In addition to that, Naviserver has special server-side templates that
are called ADP (AOLserver Dynamic Page), this is similar to ASP or JSP.
If file has an extension .adp or other extension that is registered as
ADP, server will parse it and process all known tags. At the minimum
well known [emph {<% %>}] tags are supported where Tcl scripts can be placed and
they will be processed at the time of the page render. Naviserver allows to
register custom tags and attach Tcl handlers to them, so when server
parses the page and sees those tags it will call registered Tcl handler
and it is up to the programmer how to render that tag.

[para]

The difference between registered Tcl proc and filter is that once
the Tcl proc is executed and finished, the connection is closed, it is
responsibility of that Tcl proc to provide valid HTTP response.

[para]

The registerted filter works same way as Tcl proc but there can be
multiple filters registered for the same method or URL and each filter
can decide if the processing stops here or next filter can continue
processing the request. The filters give more flexibility, there are
several stages when different set of filters are called during request
processing, those stages called preauth, postauth and trace which means
during processing of any request the server calls

[list_begin enum]

[enum] preauth filters first,

[enum] if no errors, it performs HTTP authorization if exists, usually
       everybody uses cookies nowadays, so basic HTTP authorization is rare,

[enum] then the server calls postauth filters, once the connection is closed,
       all trace filters are called.

[list_end]

[para]

The execution chain looks like this:

[list_begin enum]

[enum] accept socket
[enum] read headers
[enum] queue
[enum] preauth filters
[enum] basic authorization if required
[enum] postauth filters
[enum] Tcl proc if registered
[enum] close conection
[enum] trace filters

[list_end]

For example, default access logging is performed by trace filter, it is
written in C as a separate module, but uses the same infrastucture, so
it is easy to write your own trace filter that will do any kind of
stuff with closed connection, like logging, statistics or replication.

[para]

To show this in action there are two examples how to register Tcl
handlers in Naviserver:

[example_begin]

ns_register_proc GET /*.oss template_handler

ns_register_filter preauth GET /* security_handler
ns_register_filter postauth GET *.oss template_handler

[example_end]

First command registers Tcl proc template_handler for all requests that
end with .oss, once this callback is processed, connection is closed

[para]

Second command registers security handler to be called first for all
requests. Third command registers template handler. Security filter can
return stop return code that will tell the server not to call any
further filters otherwise server will match next filter and execute it,
if processing is till enabled the server will continue until all
matched filters are called.

[para]

OSSWEB uses those features to install its own filters for security and
template processing, security filter is registered as preauth, so it is
called early as the first filter, then if request processing
continues, template filter can be called if required.

[subsection {Security Model}]

Security filter can be registered for particular url patterns or as
global filter for the whole site. It performs session support, user
authentication and authorization. If session is not valid, user is
redirected automatically to login page. If session is valid, security
filter passes control to other filters or procs so it behaves
completely transparent to the application. It even can be disabled
completely in case of public site, but one nice feature it supports is
public sessions, for every new connection it creates new session and
assignes cookies so you can track the same user if you need it.

[para]

When HTTP request comes the only information we have is request line
with query parameters and/or cookies.

[para]

These are examples of HTTP requests:

[example_begin]

GET /index.html HTTP/1.0
GET /MyObjects/MyPortal.oss?account_id=123

[example_end]

There may be some additional headers that inform Web server about
languages and encodings the browser supports, cookies and other
information. All these headers except cookies are suplementary
information, the resource is identified by first request line. For
general purpose Web server which serves all kinds of requests including
HTML files, CGI scripts, request line basically contains file path and
name within Web server's filesystem. In order to prevent unauthorized
control to some files or scripts, Web server has various security
mechanisms. They restrict access to the whole resource by name or
directory having no knowledge about this resource and resource's
properties. When building Web application with access restrictions, or
even simple application which requires autorized access, i had to build
this security layer again for every application. Mostly because
different Web servers have different capabilities and API, even
different Apache modules has different API, so when i programmed with
Python i implemented this in Python, when i switched to PHP i had to
use PHP functions and re-write authorization again. But every time i
write this every time i do the same job.

[para]

[emph {Is it possible to create security layer that will serve security part and will be almost
independent from application itself?}]

[para]

The reason many applications have it own security implementation because
their security implementation too tightly bound to application logic. Why
not to define security functions, put it into separate API and implement
it as much independently from language or Web server as possible.

[para]

In this case application is the client to security sybsystem and should accept
some rules or restrictions that this security subsytem introduces. The
idea is not new, this is just slightly different approach for building
Web application. Instead of creating application logic and then adding
access restriction to it we can just use existing security
implementation and just use its API. Our security model is based on
naming convention for application requests. When you write your code,
you should use this convention or API for building links between
various parts of the application. Security layer is located between Web
server and your application and takes these requests and applies them
against it access database. Also we will use SQL database for storing
sesison/user related information. All this will provide us with robust
security system that can be used for many Web aplications.

[para]

The idea is that every request to our secure application web site
should be processed through security handler. This handler verifies
user credentials and allows request pass or rejects it according to
access priviliges this user has in our security database. Actually we
have two tasks which are connected, but at the same time separated from
each other. First, we need to authenticate user, in other words we have
know to who is trying to access our restricted web site. And second, we
need to determine the user's access rights to the requested resource.
Both these tasks should use the same database, at least they should
have access to the same user information. First task can be
accomplished by using cookies or native HTTP autentication method.
Second task is itself our security model implementation.

[para]

For every request that matches this pattern the security handler is
called and verifies request path, parameters and/or cookies. It tries
to check these against security permissions that are stored in database
for each particular user or group of users.

[para]

Our users and sessions tables look like this, not all columns are shown
here for brievity:

[example_begin]

TABLE ossweb_users
   user_id INTEGER
   user_name VARCHAR
   password VARCHAR
   salt VARCHAR
   salt2 VARCHAR


TABLE ossweb_user_sessions
   user_id INTEGER
   session_id VARCHAR
   ipaddr VARCHAR
   login_time TIMESTAMP
   access_time TIMESTAMP

[example_end]

[list_begin itemized]

[item] user_id will contain unique identifier for each user.

[item] user_name will contain name a user will use in order to login into the
system. password will contain encrypted user password.

[item] salt is special column which will be used for password generation and
verification.

[item] session_id will contain unique id which identifies each user session.
This is different from user_id, because session identifier will be
different for any session even for the same user. It will be used for
tracking and autorization user interaction with secure application.

[item] login_time will contain date and time a user last successful logon into
the system.

[item] access_time will contain date and time of last user request for current
session. This information will used in trackin and expiring user
sessions after some time of inactivity.

[item] ipaddr will contain IP address for current session, it is set during
login time, so even if you move browser's cookie file from one computer
to another, this will not allow to continue the same session. The
server will check IP addres from users table for this session with the
IP address of current HTTP request. Because they are different, you
will be prompted for login.

[list_end]


Users are combined into groups with the same set of access permissions.
This is very convenient, it is possible to define set of permissions
for each type of users and put these access rights into different
group. When user is created, it may be linked to corresponding group,
so there is no need to define the same permissions to each particular
user. We have here some kind of inheritance, if there is no specific
access permission for user, we will look into user's group(s).

[para]

And finally we create access permission table which will contain access
rights for each user or group. Any user can have many records in this
database, we can define as many access record as needed. There is no
technical limits, just logic of secuirty for each particular
application.

[example_begin]

TABLE ossweb_acls
   acl_id INTEGER
   obj_id INTEGER
   obj_type CHAR
   project_name VARCHAR
   app_name VARCHAR
   page_name VARCHAR
   cmd_name VARCHAR
   ctx_name VARCHAR
   value CHAR

[example_end]

[list_begin itemized]

[item] obj_id is a column which contains id from users or groups tables only.
In order to achieve this, it is possible to write trigger which will
verify that inserted ID is id either users or groups table.

[item] obj_type determines type of object that is stored in obj_id column.

[item] value contains Y if access is granted to specified in this record
application, or refued in case of N. Using N allows us to open access
to the whole context and restrict access to specific parts within this
context.

[list_end]

Other columns reflect our security model which we disscuss later in
this document.

[para]

Each user will have two cookies:

[list_begin itemized]

[item] user_id - unique permanent ID that identifies user
[item] session_id - temporary cookie that specifies particular session for
each user_id.

[list_end]

All security cookies are digitaly cryptographically
signed, so tampering of cookies is not possible. Session_id for each
user is also stored in the session table 'ossweb_user_sessions' and
periodically checked for expiration.

[para]

user_id cookie is assigned after a user successfully logged in into the
system. It is unique identifier which is primary key in the
'ossweb_users' table. We can keep this cookie for a long time in the
browser, because the same user always uses the same user_id. It is
useful for example for public sites or public open part of secured
sites. You can show some specific customized information for this
particular user, like it is done on many Web portals. When a user
provides his/her user name and password, we just look into the table
and try to find record with provided user name. In case of success we
verify provided password with existing one from database. We keep
passwords encrypted in the database using SHA1 digest encryption
algorithms. So for verification we have to calculate digest from
provided user password with the salt which is kept in the database.
This salt is just some randomly calculated string, the more unique the
salt is the more secure the system and the more difficult it to break.
Resulting encrypted string should be the same as the encrypted
password.

[para]

To store a password we do:

[list_begin itemized]

[item]  set salt with unique generated string

[item]  create encrypted password with result from SHA1(password,salt)

[item]  store encrypted password and the salt into the table

[item]  create salt2 by encrypting them using SHA1(user,password). We keep
salt2 for cases when login page supports SHA1 Javascript encryption, in
this case on the login page, when user provided name and password,
Javascript will encrypt them using SHA1 and will send that encrypted
digest to OSSWEB server, which will compare it to salt2 column. they
will match only if user provided correct name and passoword and at the
same time even without using SSL this method will never send clear text
password over the Internet.

[list_end]


To verify a user during logon:

[list_begin itemized]

[item]  find user in the database

[item]  create encrypted password by calling SHA1(password,salt)

[item]  compare encrypted password with the value of password column If the
password is correct, we generate unique session Id for this user, store
it into the table and user's browser cookie and let this user in into
the system. Also, if encrypted token was send instead of clear text
username and password, just compare it with sal2.

[list_end]

session_id cookie is assigned with every login and live for some
configured period of time. Every time a user logs into the system, new
session id is generated and assigned to a user using cookie mechanism.
Supporting session and identifying user action within session is
essential for interactive Web application. This is used for example in
shopping carts for e-commerce sites. We store session id for each user
in the same 'ossweb_user_sesions' table. Each request which contains
session_id cookie is verified with the ID of current session for each
user. If the values are different, request just refused. Also
session_id cookie is set to expire after some period of time. The
server will re-new session cookie just before they are going to expire
if user is working with the system. If user is away from his computer
and after he returned and cookie is already expired, the system will
prompt for the password in order to verify who is working.

OSSWEB instroduces the following conventions that are independent from
any application logic and those conventions are not required in full:

The security model defined the following security elements:

[list_begin itemized]

[item]  project

[item]  application

[item]  page

[item]  command

[item]  context

[list_end]

Each request will consist from 4 or 5 components:

[example_begin]

   /project_name/app_name/page_name.oss[lb]?cmd=command[lb].context[rb][rb]

   or

   /project_name/app_name/page_name.oss[lb]?cmd=command[rb][lb]&ctx=context[rb]

[example_end]

where:

[list_begin itemized]

[item] project_name is the directory, where all applications for this project
are located.

[item] app_name is the directory where all pages for this application is
located. Applications may be registered in the database. In this case
security filter will refuse any requests with invalid/unknown
application.

[item] page_name is any application-specific meaningful part of the
application logic. We can register all possible pages within an
application or allow security admin to enter any pages in permission
database. In general it is a web page name: file name with html or
dynamic server parsed page. It even can be virtual dynamic page whereby
its contents are generated on the fly by web server.

[item] cmd is optional command within current page, more like some specific
operation or action. Commmand may consist from two parts, command name
itself and command execution context. This context defines additional
logic layer inside current command operation. This is usefull when
complex application context has the same command for more than one
object within this is context. For example, command 'Move' may be
applied to files, directories, documents and urls within one repository
context.

[item] ctx is command context in different form, as a query parameter. It is
used so for convenience, because sometimes for example in submit
buttons there is impossible to use names that look like 'update.order'
or 'update.account'. It is better to use command name as 'Update' and
set command context using hidden form field.

[list_end]

Examples:

[example_begin]

/demo/knowledgebase/file.oss
/demo/knowledgebase/edit.oss
/demo/knowledgebase/file.app?cmd=move
/demo/order/search.oss
/demo/order/account.oss?cmd=show
/demo/order/account.oss?cmd=add.service
/demo/order/account.oss?cmd=add&ctx=package

[example_end]

When a request comes, security filter parses request path and splits it
into elements. We assume that request should conform to our naming
convention but if not OSSWEB will set default values for missing
elements. So, if we cannot parse command, default is set to view,
which is logically true, basically HTTP request is an attempt to view
interested us document from web server. if we have just page name, then
project, app_name and context will be set to unknown. The only part
which is required is the page name and this is basically makes us
regualr Web server which serves pages. It is important to have such
default values, it simplifies support and maintenance of access
priviliges because there should not be any unexpected behaviour or
unknown states in which the security system can be. We should know at
any time what kind of request came and what kind of resources it
requested.

[para]

After we parsed request, OSSWEB will scan access database. Database
access table 'ossweb_acls' contains all 5 tokens as columns. Each
column may contain actual value or *, which means 'everything'.

[para]

All records are sorted in a such way, that more specific rows are
always at the top and more generic at the bottom.

[para]

We retrieve permissions from 'ossweb_acls' table for the specified user
and all gropus this user belongs to. Sorting this way allows us to use
the first match because more specific matches are always ahead of more
generic ones. We do not need to scan all records every time. Because it
is possible to check access permissions inside application, we load all
permissions into memory and call special routine that will scan this
list for the match. This way we do not need to call SQL database every
time we want to verify access to some parts of our application.

[para]

For example our user has access to 2 projects, 'portal' and 'doc'.
Within project he has access to application called main. Within this
application he can execute 'view' and 'search' for any pages. The page
with user preferences 'prefs' can be updated by this user and any
commands except 'delete' can be executed in the page 'apps'.

[example_begin]

 obj_id | obj_type | project_name | app_name | page_name | cmd_name | ctx_name | value
 -----+----------+--------------+----------+-------------+----------+-------------+-------
    0 | G        | portal         | main     | apps        | delete   | link        | Y
    0 | G        | portal         | main     | apps        | delete   | *           | N
    0 | G        | portal         | main     | prefs       | update   | *           | Y
    0 | G        | portal         | main     | *           | search   | *           | Y
    0 | G        | portal         | main     | *           | view     | *           | Y
    0 | G        | doc            | *        | *           | view     | *           | Y
    0 | G        | portal         | main     | *           | *        | *           | Y
    0 | G        | unknown        | *        | *           | *        | *           | N

[example_end]

Let's assume that we have request for the page
/portal/main/apps/?cmd=view. Scanning our permission list we will find
first match at second record from the top. First three tokens are exact
match and cmd_name is '*' which means any commands. This record will
give us 'Y' which means access is allowed to this resourse. If we will
request for /portal/main/apps?cmd=delete we will match this request to
the fourth record in the permission list which will give us 'N' as a
result. Access is denied, because this user is not allowed to delete
anything except links from the application page. In order to delete
link from some application, the url should look like
/portal/main/apps?cmd=delete.link. In this case search for permission
record will stop at third record which gives us 'Y'.

[para]

The last line in the list will make OSSWEB to deny all unknown requests
regardless of the format, because by default all all security elements
set to unknown and only command is set to view, it is very easy to
define any kind fo filter that will restrict access to Web
applications.

[para]

OSSWEB has Web administrative interface that allows to create security
permissions per user or user group.

[subsection {Page Templates}]

Now, when our session is authenticated and we got the green light to
proceed to the application, OSSWEB core engine will try to route the
request to the application page. As i said above, there are multiple
way to create application pages but we start with simplest way,
projects are directories, applications are directories inside
the projects and application pages are .adp and .tcl files inside
the application directories. Thus, the request

[example_begin]

/demo/hello/world.oss?cmd=view

[example_end]

will be resolved into /demo direcotry, in that directory should exist
order/ subdirectory and in order/ subdirectory there should be at least
world.adp file. This will be our presentation layer, optional world.tcl
may exists which will provide the logic and the data for the view.

[para]

All page directories and files are located under Naviserver pageroot
which is /usr/local/ns/pages according to supplied with OSSWEB config
file. To install OSSWEB if it is not isntalled yet, refer to README
file in the OSSWEB distribution.

[para]

To create example page we should create project and aplication
directories and world.adp file:

[example_begin]

mkdir -p /usr/local/ns/pages/demo/hello

cd /usr/local/ns/pages/demo/hello

[example_end]


Create file world.adp

[example_begin]

<BODY> Hello World </BODY>

[example_end]

Now assuming that Naviserver and OSSWEB are installed and running on
port 8080 as per installation instructions, just point your browser to

[example_begin]

http://localhost:8080/demo/hello/world.oss

[example_end]

You should see Hello World, nothing fancy but simple. Now let's add
some login and scripting to this example. Let's show current date and
time with every request. We will use OSSWEB tempalting features, not
internal Naviserver ADP tags.

[para]

File world.adp

[example_begin]

<BODY>
  Hello World, current time is @current_time@
</BODY>

[example_end]


File world.tcl

[example_begin]

set current_time [lb]ns_fmttime [lb]ns_time[rb][rb]

[example_end]

Now when to point your browser to the same page you should see the
message with current time, every time you refresh the page, time
should change. In this example we just show value of the variable, the
variable is set in Tcl script file which is called before rendering
world.adp file. This is how OSSWEB templating works, when the engine
resolves the request into page and it sees that pair of world.adp and
world.tcl files exist, world.tcl file is called first, it does the
logic, then world.adp page is rendered in the same address space, i.e.
in the world.adp file you can access all variables that were created in
the world.tcl script.

[para]

Simply put, in OSSWEB templating system .tcl file prepares the data to
be shown on the page and .adp file formats and presents that data to
the user.

[para]

Let's show one more example, we add page counter to hello world
application to show how many time this page was shown. No database
will be used, we keep the counter value in memory.

[para]

Just add one more command to world.tcl file

File world.tcl

[example_begin]

set current_time [lb]ns_fmttime [lb]ns_time[rb][rb]

set counter [lb]nsv_incr HellowWorld PageCounter[rb]

[example_end]

and re-create world.adp file

[example_begin]

<BODY>
  Hello World, current time is @current_time@, page is shown @counter@ times
</BODY>

[example_end]

nsv_incr command will increment variable in the memory every time the
page is requested, this command keeps the value in the shared memory
and any thread can access it, all internal locking is done
automatically. It returns incremented value and we save it in local Tcl
variable, so world.adp page can access it and show in the html.

[para]
Let's show how processing logic can be used inside templates. We will show greeting depending on
time of day in our previous example. We will use OSSWEB registered tags.

File world.tcl

[example_begin]

set current_time [lb]ns_fmttime [lb]ns_time[rb][rb]

set hour [lb]ns_fmttime [lb]ns_time[rb] "%H"[rb]

set counter [lb]nsv_incr HellowWorld PageCounter[rb]

[example_end]

File world.adp we check variable hour and output time of day depending on the
current hour. At the end we provide link to refresh page.

[example_begin]

<BODY>
  Good
  <case>
  <when @hour@ gt 11>
      Afternoon
  <when @hour@ gt 18>
      Evening
  <else>
      Morning
  </case>
  <P>
  Hello World, current time is @current_time@, page is shown @counter@ times
  <P>
  <ossweb::link -text Refresh>
</BODY>

[example_end]

[para]
Another useful feature to show data from the database on the page, there are
several methods how to do this:

[list_begin itemized]

[item] Show Tcl list

[para]

If we need to format Tcl list we can use <list> tag:

[example_begin]

In .tcl file:

set list { one two three }


In .adp file:

<OL>
<list name=list>
  <LI> @list:item@
</list>
</OL>

[example_end]

[item] Show Tcl list as DB row

[para]
We can retrieve a row from database and store it in Tcl list,
each list item will represent separate row as Tcl list:

[example_begin]

In .tcl file:

set row [lb]ossweb::db::multilist "SELECT user_name,user_email FROM ossweb_users"[rb]


In .adp file:

<OL>
<multilist name=row>
  <LI> @row:1@, @row:2>
</multilist>
</OL>

[example_end]


[item] Show DB row

[para]
We can retrieve multiple records from database and store them in
so-called datasource, which is a collection of Tcl arrays:

[example_begin]

In .tcl file:

ossweb::db::multirow rows "SELECT first_name,last_name,user_email FROM ossweb_ursers" -eval {

  set row(full_name) "$row(first_name) $row(last_name)"
}

In .adp file:

<multirow name=rows>
  @rows.full_name@
  <if @row.user_email@ ne ""> Email: @rows.user_email@ </if>
  <BR>
</multirow>

[example_end]


[item] Show DB row in the tag

[para]
Show records without any .tcl file

[example_begin]

<foreach name=row query="SELECT user_name FROM ossweb_users">
 @row.user_name@
</foreach>

or

<foreach name=row query=sql:ossweb.user.list>
 @row.user_name@
</foreach>

[example_end]

[list_end]


[subsection {Request Routing}]

Once the server found and called our page, it is up to us what to do
next. We can retrieve all query parameter using ns_queryget command and
perform our logic and return HTTP response back to client. But doing
all that over and over again for every page would be tedious and time
consuming. OSSWEB offers flexible request routing method that will
simplify request processing and minimize amount of code that needs to
written.

[para]

Because security handler parses and splits request into pre-defined
elements, inside the page we know which command was requested. We just need
to write so-called callback on that command that will be automatically
called. Inside that callback you need to write only what is related to
that particular command. In OSSWEB that means every page needs to call
ossweb::conn::process command. It accepts list of commands and corresponding
callbacks to call, also you can specify where to go after successfull
execution of the callback and where to go in case of error. Of course
every callback can do routing itself to the next point as well, it is up to
you to decide how it is more convenient in this particular application.

[para]

Let's show how the code looks like:

[example_begin]

# Update record
ossweb::conn::callback update {} {
   ...
}

# Read record from the DB and show form
ossweb::conn::callback edit {} {
   ...
}

# View all records
ossweb::conn::callback view {} {
   ...
}

ossweb::conn::process \
     -eval {
       update {
         -exec update
         -next "cmd view"
         -on_error "cmd edit"
       }

       edit {
         -exec edit
         -on_error "cmd edit"
       }

       default {
         -exec view
       }
     }

[example_end]

The example above defines 2 callbacks for each command it supports,
ossweb::conn::process has -eval block which is similar to switch
statement whereby for each command there is another block that defines
what to do. For example, update command shoudl execute callback
"update". If there is no error, next action will be "view". In case of
error, next action will be "edit".

[para]

The way the "next" statement works, it re-evaluates the same page, i.e.
re-executes ossweb::conn::process again with new command. But it
re-evaluates itself in the same address space, so all Tcl variables
and other objects are available. Deep inside OSSWEB actually does not
parse the same Tcl file more than once, after the first time, Tcl code
is compiled, wrapped into Tcl proc and cached by the Tcl interpreter,
so next time OSSWEB actually just calls the Tcl command, no reading and
parsing involved. But OSSWEB monitors the file and if it was modified,
it is reloaded and recompiled.

[para]

For example let's assume update callback failed with some error, OSSWEB
sees the "-on_error" statement, sets system command to "edit" and
re-evaluates the page again. Now ossweb::conn::process is called with
command edit, so OSSWEB calls callback "edit" which does something, for
example shows the form to the user with error message.

[para]

If no errors occured in "update" callback, "-next" statement sets
command to "view", OSSWEB re-evaluates the page and callback "view" is
called which will show all records including just made changes.

[para]

Actually, the above form is kind of verbose, another way to do the same
is to rely on OSSWEB ability to automatically call callbacks for each
command. Only in this case we have to handle errors and routing in
every callback.

[example_begin]

# Update record
ossweb::conn::callback update {} {
   ...
   ossweb::conn::next cmd view
}

# Read record from the DB and show form
ossweb::conn::callback edit {} {
   ...
   ossweb::conn::next cmd view
}

# View all records
ossweb::conn::callback view {} {

}

ossweb::conn::process \
     -on_error "cmd view"

[example_end]

If you take a look at the new example, basically it works the same way
as previous one, but OSSWEB calls callback by command name and we
defined global error handler to switch to command "view" on any error
in any callback.

[para]

Also, callbacks "update" and "view" now define what to do after they
finish, they call special command ossweb::conn::next which
changes execution context and sets new command to "view".

[para]

This looks simple but make the code and programming more like writing
callbacks and routing between them. Another useful feature is that
ossweb::conn::process converts incoming query parameters into local Tcl
variables, so ther are accessable in every callback. For security
reasons, not all parameters get converted, only those you are
interested in.

[para]

The format is list of triples: varname type default_value ....

[para]

For example:

[example_begin]

ossweb::conn::callback view {} {

    if { $id != "" } {
      ...
    }
}

ossweb::conn::process \
     -columns { id int ""
                name "" "" }


[example_end]

tells OSSWEB to create variables "id" and "name" with empty string as
default value, so when page is called those variables are available and
no need to verify their existence. If query parameters "id" or "name"
were given in the url, then values will be stored in corresponding
variables. Type "int" will enforce value of parameter id to be integer,
if not, value will be ignored.

[para]

There is possible to keep different command in the different files and
route requests flow between pages as well.

[para]

This is page update.tcl

[example_begin]

# Update record
ossweb::conn::callback update {} {
   ...
   ossweb::conn::next -page view -cmd view
}

ossweb::conn::process -on_error "-page view -cmd edit"

[example_end]


This is page edit.tcl

[example_begin]

set id [lb]ossweb::sql::quote [lb]ns_queryget id[rb][rb]

if { [lb]ossweb::db::multivalue "SELECT * FROM account WHERE id=$id"[rb] } {
  ossweb::conn::set_msg "Unable to read account record"
  ossweb::conn::next -cmd error -page index
  return
}

[example_end]

This is page view.tcl

[example_begin]

# View all records
ossweb::conn::callback view {} {
   ...
}

ossweb::conn::process -on_error index

[example_end]

In the example above we have 3 files, update.tcl, edit.tcl and view.tcl
that perform some specific actions. Routing between them now has
additional parameter that tells name of the page which to call and that
means that OSSWEB will locate and call that page and execute specified
command in that page. edit.tcl does not even have ossweb::conn::process
call because it reads the record, stores all columns in the local Tcl
variables and exit. In case of error, it passes control to index page
and sets system error message that will be shown by index page
for example.

[subsection {Database Access}]

OSSWEB provides high level access to databases using native Naviserver database drivers and
database API. Naviserver includes drivers for most databases like PostgreSQL, MySQL, Oracle,
Informix, Interbase, Sybse, SQL Server, Berkeley DB. OSSWEB supports PostgreSQL only.

[para]

In order to access databse, it needs to be configured in the main Naviserver config file,
it includes so called database pools, when access to each database has unique name which is
used in the applications, never any application uses database username or passwords directly.
This makes applications very portable and independent of specific database, just update config
file and application will use different database server. Applications just request database handle
from the named pool, if no connections to the database yet, Naviserver connects to databse, and
returns the handle to the caller. Once application is done, it returns handle back to the pool
and any other thread can reuse already opened database handle. This way not too many open
connections to database are able to maintain very high number of users or working threads.

[para]
OSSWEB does not provide any mapping or object layer on top of SQL access. Database API
provides one-to-one mapping between database columns and Tcl variables. Once read from
the database program can access values from the SQL tables as Tcl variables. For updates
Tcl variables will be used as well for corresponding SQL columns. It is up to the program
to set them with appropriate values. There are helper procs that make working with database
even more easier and there is object system module otcl that provides dynamic objects similar
to Ruby or Python that can be used to build object-oriented layer. In most cases storing and
manipulating Tcl variables or arrays with database access is enough.

[para]
There are several API calls available for the developer:

[list_begin itemized]

[item] [emph {ossweb::db::value sql}]

[para]
This call returns single value, given SQL statement should be SELECT or stored procedure call.

[example_begin]

set date [lb]ossweb::db::value "SELECT NOW()"[rb]

[example_end]

[item] [emph {ossweb::db::list sql}]

[para]
This call returns list of columns from all records that met the given criteria.

[example_begin]

set names [lb]ossweb::db::list "SELECT user_name FROM ossweb_users"[rb]
foreach name $names {
  ns_log notice Column: $name
}

[example_end]

[item] [emph {ossweb::db::multivalue arg sql}]

[para]
This call reads specified columns from the given row and stores them in the local
Tcl variables with the same names

[example_begin]

if { [lb]ossweb::db::multivalue "SELECT user_id,user_name FROM ossweb_users WHERE user_id=1"[rb] } {
  error "Record not found"
}
ns_log Notice User ID : $user_id
ns_log Notice User Name : $user_name


[example_end]

[item] [emph {ossweb::db::multilist sql}]

[para]
This call returns a list of all records that met the critwria where each item is a Tcl list
with all the specified columns.

[example_begin]

set users [lb]ossweb::db::list "SELECT user_id,user_name FROM ossweb_users"[rb]
foreach user $users {
  foreach { user_id user_name } $user {}
  ns_log notice User: $user_id $user_name
}

[example_end]

[item] [emph {ossweb::db::multirow name sql}]

[para]
This call prepares so-called datasource with given name which then can be used in the template
using <multirow> tag. Basically this is a list of records which can be accessed by index and name.

[example_begin]

ossweb::db::multirow users "SELECT user_id,user_name FROM ossweb_users"

[example_end]

and in .adp template we can easily show the list of users as

[example_begin]

<UL>

<multirow name=users>
 <LI> @users.user_id@ @users.user_name@
</multirow>

</OL>

[example_end]

[item] [emph {ossweb::db::multipage sql1 sql2}]

[para]
This call is similar to multirow but uses 2 SQL statements instead of one and
provides ability to split many records into pages. First SQL statement receives
all primary keys meeting given criteria, second statement just shows one page at
a time. Keys are caches, so every time page number is given, the only second
SQL statement is called to retrieve records for given page.

[example_begin]

ossweb::db::multipage users \
     "SELECT user_id FROM ossweb_users" \
     "SELECT user_id,user_name,user_email FROM ossweb_users WHERE user_id IN (CURRENT_PAGE_SET)" \
     -page $page

ossweb::conn::process -columns { page int 1 }

[example_end]

First time when called, page is assigned with default value of 1, so datasource users
will contain records for tthe first page. Tag <multipage> will generate standard back and
forward links with list of all pages. When clicked on page number, it will be passed
with query parameters and initialized in Tcl variable page. Subsequent calls to
ossweb::db::multipage with the same SQL statements and different page number will
use cached list of keys and execute only second statement with CURRENT_PAGE_SET substituted
with list of keys for given page.

[para]

in .adp template we can show all pages using paginator

[example_begin]

<multipage name=users>

<UL>

<multirow name=users>
 <LI> @users.user_id@ @users.user_name@
</multirow>

</OL>

<multipage name=users>

[example_end]


[item] [emph {ossweb::db::foreach sql script}]

[para]
This call will execute SQL statment and will call given Tcl script for every retrieved record. All
column values for each iteration will be assigned to local Tcl variables with the same names.

[example_begin]

ossweb::db::foreach "SELECT user_id,user_name FROM ossweb_users" {
  ns_log notice $user_id $user_name
}

[example_end]

[item] [emph {ossweb::db::exec sql}]

[para]
This call executes DDL statements like UPDATE, INSERT, DELETE and etc. It returns 0 if successful or
-1 in case of error.

[example_begin]

if { [lb]ossweb::db::exec "DELETE FROM ossweb_users WHERE user_id=1"[rb] } {
  error "Unable to delete the record"
}

[example_end]

[item] [emph {ossweb::db::insert table args}]
[item] [emph {ossweb::db::update table keys args}]
[item] [emph {ossweb::db::delete table keys args }]
[item] [emph {ossweb::db::read table keys args }]
[item] [emph {ossweb::db::select table keys args }]
[item] [emph {ossweb::db::arrays table keys args }]
[item] [emph {ossweb::db::scan table keys args }]

[para]
These calls will execute SQL Insert,Update and Delete commands respectifully. Columns is list of
field definitoons in the same format as in ossweb::db::insert_values command. key parameter can be
a Tcl list in which case Where condition in update/delete calls will use all specified fields.
-columns can be omitted, OSSWEB will read column definitions from the database.

[example_begin]

set msg_name Test
set description "Test message"
ossweb::db::insert ossweb_msgs

# Update record with msg_name=Test with new description Test2
ossweb::db::update ossweb_msgs msg_name Test -columns { description "" Test2 }

# Delete record by msg_name=Test and description=Test2
ossweb::db::delete ossweb_msgs msg_name Test description Test2

# Retrieve all records with msg_name=Test
set recs [lb]ossweb::db::select ossweb_msgs msg_name Test[rb]

# Same as above but store columns in local Tcl variables,
# this is equivalent of "SELECT * FROM ossweb_msgs WHERE msg_name='Test'"
ossweb::db::read ossweb_msgs msg_name Test

# Go through all records
ossweb::db::scan ossweb_msgs -eval {
  ns_log notice $msg_name
}

# Return record as array
set rec [lb]ossweb::db::arrays ossweb_msgs msg_name Test[rb]
array set arec $rec

# Same as above
ossweb::db::read ossweb_msgs msg_name Test -array rec

[example_end]


[item] [emph ossweb::db::begin]
[item] [emph ossweb::db::commit]
[item] [emph ossweb::db::rollback]

[para]
These calls are used to define transactions. Nested calls are allowed, it will count
nesting level and only first begin and last commit/rolback will be actually executed.

[item] [emph ossweb::db::rowcount]

This call returns number of rows processed by last UPDATE or DELETE commands.

[item] [emph {ossweb::db::filter options}]

[para]
This call is used to construct SQL conditions based on input Tcl variables. This is mostly
useful in SELECT statemets that used for searching record based on varibale input from user or
other sources.

[example_begin]

ossweb::sql::filter \
     { user_id ilist ""
       user_name Text ""
       user_email text "" }

[example_end]

Previous example will return empty string if none of user_id,user_name or user_email variables exists.

[para]
Let's say we assign variable user_id with value 1. Now ossweb::sql::filter will return "user_id IN (1)".

If we assign Tcl variable user_name with john then we will get the following SQL:
[para]

"user_id IN (1) AND user_name ILIKE '%john%'".

[para]

If we define user_email with a, then the whole result will be

[para]

"user_id IN (1) AND user_name ILIKE '%john%' AND user_email ILIKE 'a%'"

[item] [emph {ossweb::db::insert_values options}]
[item] [emph {ossweb::db::update_values options}]

[para]
These calls are used to build SQL statemenst for INSERT and UPDATE commands. They accept list of columns
and then check local Tcl variables with same names for values. Columns list tells how any particular
value should be encoded in SQL. This is very flexible way of dynamically build SQL statements based on
variable input.

[example_begin]

ossweb::db::exec "INSERT INTO ossweb_users
                  [lb]ossweb::sql::insert_values -full t \
                           { user_id int ""
                             user_name "" ""
                             user_email "" ""
                             status "" active }[rb]"

ossweb::db::exec "UPDATE ossweb_users
                  SET [lb]ossweb::sql::update_values -skip_null t \
                           { user_id int ""
                             user_name "" ""
                             user_email "" ""
                             status "" active }[rb]"

[example_end]

Previous example will add new user record using local Tcl variables as values. status column if not
defined will be assigned with default value of "active". When updating, -skip_null tells that empty or
non-existent columns should not be used in UPDATE statement, thus allowing to update only changed
columns.

[list_end]

[subsection {SQL Query Abstraction}]

Sometimes application may do similar tasks or similar database actions in different places.
Duplicating the same SQL statements and in case of minor change going through all source code may
be not fun to do. OSSWEB offers flexible solution, it is called SQL query abstraction.

[para]
In every place where SQL statement is expected, mostly in database API calls, instead of pure SQL
code it is possible to use SQL ids. Those ids are uniquely identify SQL statements and used
similar to procedure or API calls. It is stored in .xql files using very simple XML format with
given query id, then applications can refer to that id and execute SQL statement as they are
given them directly. But, one feature that makes it even more flexible and usefull, those stored
statements can containt Tcl code and refer to Tcl variables, before passing to database for execution,
that XQL definition will be processed by Tcl or better say to executed by Tcl and the resulting SQL
statement will be passed to the database for execution.

[para]
Let's see this in example, we will use SQL statements from previous section.

We create users.xql file and put there all our SQL statements.

[example_begin]

<query name="ossweb.user.list">
  <description> List of all users </description>
  <sql>
   SELECT user_id,user_name,user_email FROM ossweb_users
  </sql>
</query>

[example_end]

By default all .xql files are stored under /usr/local/ns/xql, just drop new file there and
OSSWEB server will detect and pick it up.

[para]

Now we take previos example they will look like this:

[example_begin]

ossweb::db::multirow users sql:ossweb.user.list

set users [lb]ossweb::db::list sql:ossweb.user.list[rb]
foreach user $users {
  foreach { user_id user_name } $user {}
  ns_log notice User: $user_id $user_name
}

ossweb::db::foreach sql:ossweb.user.list {
  ns_log notice $user_id $user_name
}

[example_end]

Same query is used in all parts of code, in some ways this amy look less readable, but if using
proper names for queries they will tell you exactly what they are doing and if SQL is not what needs to
modified or developed, this abstraction makes Tcl code even more readable.

[para]
Also it is worth to mention that if i need to change that SQL and make it globally that users with status 'disabled'
should not appear anywhere i just go and change one particular XQL file and query.

[example_begin]

<query name="ossweb.user.list">
  <description> List of all users </description>
  <sql>
   SELECT user_id,user_name,user_email FROM ossweb_users WHERE status <> 'disabled'
  </sql>
</query>

[example_end]

If xql file has been changed, OSSWEB will detect modification and re-read that file, so new query will immediately
be used in the application. In real production it is possible to disable runtime checks for modified file
to gain more performance but in development and no so busy sites, this ability to tune SQL without touching
code is very usefull and leads to faster and better maintanance. Of course, production system are not supposed
to be touched at all but in real life the opposite happens quite often.

[para]
Another area where .xql files are useful is to make conditional SQL statements.  Let's assume that we want to use only
this SQL statement to all access to ossweb_users table. But we have search page which may take input of how somebody
wants to locate particular user, let's say by user_name or/and by user_email. XQL definition allows to embed Tcl
directly into SQL query and also allows to define required Tcl variables with default values.

[example_begin]

<query name="ossweb.user.list">
  <description>
   List of all users
  </description>

  <sql>
   SELECT user_id,user_name,user_email
   FROM ossweb_users
   WHERE status <> 'disabled'
         [lb]ossweb::sql::filter \
                  { user_id ilist ""
                    user_name Text ""
                    user_email Text "" } \
                  -before AND[rb]
  </sql>
</query>

[example_end]

Now, if no Tcl variables user_id,user_name,user_email exist, this query will return all records. But when used
in search page and user submitted values for any of those fields, SQL query will be constructed with additional
conditions. It is possible to use different Tcl variable names and then map then, this will be explained in more
details in API sections.

[section {Installing OSSWEB}]

[subsection {PostgresQL Installation}]

PostgreSQL should be installed and running before you do OSSWEB installation.
If it is not installed, before installing OSSWEB you need to perform PostgreSQL
setup;

[example_begin]

make install_pgsql

[example_end]

This command will download and install PostgreSQL into /usr/local/pgsql and
start the database server. Now time for OSSWEB installation.

[subsection {OSSWEB Installation}]

To prepare the environment just download OSSWEB from
[uri ftp://ftp.crystalballinc.com/pub/vlad/ossweb.tar.gz].

[example_begin]

wget ftp://ftp.crystalballinc.com/pub/vlad/ossweb.tar.gz
tar -xzf ossweb.tar.gz
cd ossweb

[example_end]

[para]
If PostgreSQL was installed manually and is running with your privileges
and not as user postgres then:

[example_begin]

make install_world dbuser=`whoami`

[example_end]

or if PostgreSQL is provided by your Linux distribution and is already running with
privileges of user [emph postgres]:

[example_begin]

make install_world

[example_end]

The command above will download, compile and install Naviserver into /usr/local/ns. It
provides default config file which accesses local PostgreSQL database named [emph ossweb]
and listens on port 8080 for HTTP requests. To start the server in the shell just type:

[example_begin]

/usr/local/ns/bin/nsd -f

[example_end]

-f flag tells to start in foreground so the server can be stopped by pressin Control-C. If
background execution is preferred, just do not specify -f flag, server will detach itself from
the terminal. Pointing your browser to [uri http://localhost:8080] should display default Naviserver
index page.

[para]

Typing [uri http://localhost:8080/ossweb/] will bring OSSWEB login screen, just enter
username [emph admin] with password [emph admin]. It will bring initial OSSWEB admin
pages with menu on the left with installed applications.

[para]

[subsection {Development Mode}]

By default OSSWEB config file enables development mode in which there is no need to restart
the server even in case library files are changed. OSSWEB will detect changes to Tcl files and
will reload them automatically.

[para]
The following parameters define development mode:

[list_begin enum]

[enum] ns_param server:development t
Enable development mode. Also the server searches local direcotory where
current page is being served for .xql files. In production mode all .xql files
should be put into /usr/local/ns/xql directory but in develpment mode modules
can be developed initially in their local folders.

[enum] ns_param server:debug t
This parameter enables global debug output for incoming requests, nsd.log will contain
the complete trace of what is called during every request which makes debugging and tracing
much easier.

[list_end]

[section {Tutorial: First Application}]

To show the whole process how to build applications for OSSWEB, let's create photo album
application, from the beginning to complete web site. The application will not be
feature complete but pretty functional and useful.

[subsection {Database Model}]

We will have 2 tables, albums and photos. albums table will hold list of albums with
name and creator, photos will be for keeping list of photes for each album.

[example_begin]

CREATE SEQUENCE album_seq;

CREATE TABLE album (
  album_id INTEGER NOT NULL DEFAULT NEXTVAL('album_seq'),
  album_name VARCHAR NOT NULL,
  album_descr VARCHAR NULL,
  user_id INTEGER NOT NULL DEFAULT 0 REFERENCES ossweb_users(user_id),
  create_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  PRIMARY KEY(album_id)
);

CREATE TABLE photo (
  album_id INTEGER NOT NULL REFERENCES album(album_id),
  photo_name VARCHAR NOT NULL,
  photo_size INTEGER NOT NULL,
  create_date TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW(),
  PRIMARY KEY(album_id,photo_name)
);

[example_end]

Execute those statements in the psql, just copy them and paste
in the PostgreSQL shell which can be invoced as:

[example_begin]

/usr/bin/psql -U postgres ossweb

or

/usr/local/pgsql/bin/psql ossweb

[example_end]

Now we have 2 options, we can write all code manually or we can use
OSWEB Page Generator to create some initial templates and SQL queries
for us. To generate code, point your browser to
[uri http://localhost:8080/ossweb/admin/generator.oss]

[para]
For the sake of explanation what we are doing this tutorial will
show how to create applications manually.

[subsection {Albums List}]

After we created SQL tables we want to create new albums and be
able to list, modify and delete them. Let's call our application
[emph photo].

[example_begin]

mkdir -p /usr/local/ns/pages/photo

cd /usr/local/ns/pages/photo

[example_end]

Now use your favorite text editor and create file album.tcl.

[example_begin]

ossweb::conn::callback view {} {

   ossweb::db::multirow albums "SELECT *,ossweb_user_name(user_id) AS user_name FROM album ORDER BY 1"
}

ossweb::conn::process \
     -default view

[example_end]

and then we create file album.adp

[example_begin]

<ossweb:header>

<BODY>

<CENTER><ossweb:msg></CENTER><BR>

<ossweb:title>Photo Albums</ossweb:title>

<CENTER>
  <ossweb:link -text "Create New Album" cmd edit>
</CENTER>

<border style=white>
<TR><TH>Album Name</TH><TH>Created</TH><TH>Owner</TH></TR>

<multirow name=albums>
  <TR><TD>@albums.album_name@</TD>
      <TD>@albums.create_date@</TD>
      <TD>@albums.user_name@</TD>
  </TR>
</multirow>

</border>

</BODY>

<ossweb:footer>

[example_end]

The code above defines callback command [emph view] which will be
called by default. When request comes and OSSWEB does not see any
specific command given, it will call command view. This callback just
retrieves all records from album table and puts them into datasource
named albums.

[para]
In album.adp we show datasource albums using <multirow> tag, parameter name
specifies which named datasource to use. This tag repeats HTML block for every
row in the datasource. Inside that tag, columns refered by their names.
Other OSSWEB predefined tags are:

[list_begin itemized]

[item] <ossweb:header> - renders all required javascript, CSS and other
         necessary files and information.

[item] <ossweb:msg> - if during execution error message was set, this tag will
         show it

[item] <ossweb:title> Formats HTML title

[item] <border> - creates HTML table with style white, there are more styles
         for border tag. [uri http://localhost:8080/ossweb/admin/generator.oss {Page Generator}]
         can be used to preview all border formats.

[item] <ossweb:footer> - render other internal OSSWEB information which needs to be kept
         on the page, ussualy header and footer tags are required for proper template
         rendering, otherwise a lot of things will need to be done manually like including
         .js and .css files and hidden <div> tags.

[list_end]

[para]
Now we can point our browser to [uri http://localhost:8080/photo/album.oss].

[subsection {Creating Albums}]

To create new album we need to define form with fields and 2 callbacks,
one will be called on form invokation and another on form submittion.

[example_begin]

# Retrieve all albums
ossweb::conn::callback view {} {

   ossweb::db::multirow albums "SELECT *,ossweb_user_name(user_id) AS user_name FROM album ORDER BY 1"
}

# Create new album, fire error on SQL error
ossweb::conn::callback create {} {

   ossweb::db::insert album \
        -error t

   ossweb::conn::set_msg "Album has been created"
   ossweb::conn::next cmd view
}

# Nothing yet
ossweb::conn::callback edit {} {

}

# Declare form for album details
ossweb::conn::callback create_form_album {} {

   ossweb::form form_album -title "Album Details"

   ossweb::widget form_album.album_name -label Name

   ossweb::widget form_album.album_descr -type textarea -label Description \
        -resize \
        -cols 50 \
        -rows 2 \
        -optional

   ossweb::widget form_album.cmd -type submit -label Create

   ossweb::widget form_album.back -type button -label Back \
        -url "cmd view"
}

# Request controller, declare Tcl variable album_id, create form form_album
# and perform request routing
ossweb::conn::process \
     -columns { album_id int "" } \
     -forms form_album \
     -default view

[example_end]

Let's explain what we've just added. New callback create will be
called when form with album info will be submitted. It will insert
new record into table album.

[para]

Second argument is a Tcl list with column definitions, for now we have album name and user_id.
Column definitions is a list with triples, column name, column type
and default value. For each column name ossweb::db::insert will
try to see if Tcl variable with such name exists and if so, its value
will be used in construction SQL insert statement. Type "" means that
column is VARCHAR, so it will be properly quotes and escaped. Next
column is user_id, type userid means that value will be assigned with
current session's user id. Once SQL statement is built it will be
executed and we will return message about successful operation.

[para]
-error t flag tells ossweb::db::insert to raise exception in case any SQL runtime
error, in this case transaction will be aborted if any and OSSWEB will
stop processing callback and by default convention will re-route to command
error. In our example we do not handle error command so control will be passed
to view command which will show existing album list and <ossweb:msg> tag will render
current error condition. Another defaut convention, in case of any form validation error,
for example widget album_descr is described as optional but widget album_name is not,
which means it is required. If you try to submit form with empty album_name, error condition
will happen because form will not be validated, in this case control will be re-routed to
command edit.

[para]
Callback edit will be called on clicking
[uri http://localhost8080/photo/album.oss?cmd=edit {Create New Album}] link.
Because we do not provide album_id we just show empty form. -forms form_albums clause
in ossweb::conn::process tells OSSWEB that we need to prepare form named form_album.
By convention, OSSWEB will call create_form_album callabck which should create the form.
In out form we create 2 input widgets, name and textarea for description and 2 buttons,
one for submit and another for returning back to the list.

[para]
Once the form filled, hit the Create button, new album should be created. But before that, we need to update
album.adp file as well. Currently it does not know how to handle edit command.

[example_begin]

<ossweb:header>

<BODY>

<CENTER><ossweb:msg></CENTER><BR>

<if @ossweb:cmd@ eq edit>

   <formtemplate id=form_album></formtemplate>

<else>

   <ossweb:title>Photo Albums</ossweb:title>

   <CENTER>
     <ossweb:link -text "Create New Album" cmd edit>
   </CENTER>

   <border style=white>
   <TR><TH>Album Name</TH><TH>Created</TH><TH>Owner</TH></TR>

   <multirow name=albums>
     <TR><TD>@albums.album_name@</TD>
         <TD>@albums.create_date@</TD>
         <TD>@albums.user_name@</TD>
     </TR>
   </multirow>
   </border>
</if>

</BODY>

<ossweb:footer>

[example_end]

In new album.adp file now we check what is current command and in case of edit
we will show album form.

[subsection {Updating Albums}]

For updating albums we need to be able to click on the existing album,
update albums fields and save it back into the database. album.adp template will
not change because we do not chnage the layout. New features will be added in
the album.tcl.

[example_begin]

# Show all albums
ossweb::conn::callback view {} {

   ossweb::db::multirow albums "SELECT *,ossweb_user_name(user_id) AS user_name FROM album ORDER BY 1" -eval {

     # Convert album_name field into link which points to album edit page
     set row(album_name) [lb]ossweb::html::link -text $row(album_name) -title $row(album_descr) cmd edit album_id $row(album_id)[rb]
   }
}

# Create new album record
ossweb::conn::callback create {} {

   ossweb::db::insert album \
        -error t

   ossweb::conn::set_msg "Album has been created"
   ossweb::conn::next cmd view
}

# Update existing album record by album_id
ossweb::conn::callback update {} {

   ossweb::db::update album \
        -error t \
        album_id $album_id \
        user_id $user_id

   ossweb::conn::set_msg "Album has been updated"
   ossweb::conn::next cmd view
}

# Delete existng album record by album_id and user_id
ossweb::conn::callback delete {} {

   ossweb::db::delete album \
        -error t \
        album_id $album_id \
        user_id $user_id

   ossweb::conn::set_msg "Album has been deleted"
   ossweb::conn::next cmd view
}

# Album record details
ossweb::conn::callback edit {} {

   # New record, do nothing
   if { $album_id == "" } {
     return
   }

   # Read record by album_id
   if { [lb]ossweb::db::read album album_id[rb] } {
     error "OSSWEB: Invalid album id $album_id"
   }

   # Convert Create label into update command
   ossweb::widget form_album.cmd -label Update

   # Add delete button if this is our album
   if { $user_id == [lb]ossweb::conn user_id[rb] } {

     ossweb::widget form_album.delete -type button -label Delete \
          -confirmtext "Album will be deleted, continue?" \
          -url "cmd delete album_id $album_id"
   }

   # Update form with values fromTcl variables
   ossweb::form form_album set_values
}

# Definition of form for album
ossweb::conn::callback create_form_album {} {

   ossweb::form form_album -title "Album Details"

   ossweb::widget form_album.album_id -type hidden \
        -datatype int \
        -optional

   ossweb::widget form_album.album_name -label Name

   ossweb::widget form_album.album_descr -type textarea -label Description \
        -resize \
        -cols 50 \
        -rows 2 \
        -optional

   ossweb::widget form_album.cmd -type submit -label Create

   ossweb::widget form_album.back -type button -label Back \
        -url "cmd view"
}

# Controller that perform rquest processing and routing
ossweb::conn::process \
     -columns { album_id int ""
                user_id userid 0 } \
     -forms form_album \
     -default view

[example_end]

Callback view now has -eval parameter which is Tcl script that will be called for
every row. Inside that script Tcl array [emph row] is automatically created with all columns set
for the current record. In our case we build url so album name will be clickable and set link title to
album description. when mouse over on album name and hold it, yellow tip will appear with
description. On click, command edit will be called with given album id.

[para]

Callback update is similar to create, we just update given record with
modified fields. user_id now just integer column, we assign user_id Tcl variable
at the beginning with current user id or 0 if not logged in.

[para]

Delete callback will delete album by album_id and user_id, that means that i can
delete only created by me albums

[para]

Callback edit is what handles edit command. If album_id is provided we will try
to read the record. In case of wrong id we just fire error message which will be shown
on the page using <ossweb:msg> tag. If we was able to locate the record, ossweb::db::read
will create local Tcl variables with the same names as column names. In our case we will
have album_id, album_name, album_descr, user_id, create_date variables.

[para]

Also widget cmd is changed with new label Update, on submit, it will make
the command to be update (cmd and ctx parameters always converted into lowercase because
they are reserved word and commands are lowercase only). New widget delete is added which will
provide ability to delete existing album.

[para]

In the form definition we added new hidden widget album_id with datatype integer, this will
have the form validate album_id on submitions and will guard against SQL-injection attacks.

[para]

The last change worth mentioning is -columns parameter for ossweb::conn::process. It now has 2 items,
we added user_id which is described as const. That means it will be assigned once on page invocation.
In case if in the url user_id=something will be sent, it will be ignored.
[lb]ossweb::conn user_id 0[rb] means return current user id if logged in or 0 as default if no user
session currently exists.

[subsection {Uploading Photos}]

Now we are ready to upload some pictures into our albums. There are different ways to do this but we will
choose simple way with some additional features to show what OSSWEB can do. The GUI will have tabs on top of the
album form, default will be album details, then Upload and Photos. In Upload section we will provide several upload
buttons to be able to send more than one picture, in the Photos section we will format all photos as thumbnails.

[para]

In album.adp file we added tabbed buttons using tag <formtab> and 2 new sections in edit mode.
Tcl variable tab will be used for switching between different tabs. When we show photos, we
use table with 3 pictures in each row.

[para]
We refer to @photos:rowcount@ which is predefined variable created automatically for each
multirow datasource. It hods number of records in the record set. If no uploaded pictures,
we show message, otherwise HTML table with 3 pictures in the row. For each row, <multirow>
tag automatically assigned Tcl variable @photos:rownum@ with current row sequential number
starting with 1.

[para]

[example_begin]

<ossweb:header>

<BODY>

<CENTER><ossweb:msg></CENTER><BR>

<if @ossweb:cmd@ eq edit>

   <formtab id=form_tab>

   <case>

   <when @tab@ eq upload>

       <formtemplate id=form_upload></formtemplate>

   <when @tab@ eq photos>

       <if @photos:rowcount@ nil or @photos:rowcount@ eq 0>

          There are no uploaded pictures in this album yet.

       <else>

          <TABLE BORDER=0 WIDTH=100% >
          <TR>

          <multirow name=photos>
          <TD>@photos.photo_url@<BR>
              @photos.photo_name@: @photos.photo_size@
          </TD>

          <if @photos:rownum@ not mod 4>
             </TR><TR>
          </if>

          </multirow>

          </TR>
          </TABLE>

       </if>

   <else>

       <formtemplate id=form_album></formtemplate>

   </case>

<else>

   <ossweb:title>Photo Albums</ossweb:title>

   <CENTER>
     <ossweb:link -text "Create New Album" cmd edit>
   </CENTER>

   <border style=white>
   <TR><TH>Album Name</TH><TH>Created</TH><TH>Owner</TH></TR>

   <multirow name=albums>
     <TR><TD>@albums.album_name@</TD>
         <TD>@albums.create_date@</TD>
         <TD>@albums.user_name@</TD>
     </TR>
   </multirow>
   </border>
</if>

</BODY>

<ossweb:footer>

[example_end]

Now album.tcl needs to be extended. this will be our final version of the application, so below is
the full source code for the album.tcl and after it will follow explanation of what was changed or
added.

[example_begin]

# Read all album records
ossweb::conn::callback view {} {

   ossweb::db::multirow albums "SELECT *,ossweb_user_name(user_id) AS user_name FROM album ORDER BY 1" -eval {

     # Convert album_name into link that points to album edit page
     set row(album_name) [lb]ossweb::html::link -text $row(album_name) -title $row(album_descr) cmd edit album_id $row(album_id)[rb]
   }
}

# Create new album record, if successfull return to view mode
ossweb::conn::callback create {} {

   ossweb::db::insert album \
        -error t

   ossweb::conn::set_msg "Album has been created"
   ossweb::conn::next cmd view
}

# Update existing album record by album_id, if successfull return to view mode
ossweb::conn::callback update {} {

   ossweb::db::update album \
        -error t \
        album_id $album_id \
        user_id $user_id

   ossweb::conn::set_msg "Album has been updated"
   ossweb::conn::next cmd view
}

# Delete existing album by album_id and user_id
ossweb::conn::callback delete {} {

   ossweb::db::delete album \
        -error t \
        album_id $album_id \
        user_id $user_id

   ossweb::conn::set_msg "Album has been deleted"
   ossweb::conn::next cmd view
}

# Save uploaded pictures
ossweb::conn::callback upload {} {

   # Root path where we store images
   set path [lb]ns_info pageroot[rb]/photo

   # For all 2 pictire input fields
   for { set i 1 } { $i <= 5 } { incr i } {

     # Store uploaded image into our directory
     set photo_name [lb]ossweb::file::upload file$i -path $path -mode path[rb]

     # Check if image exists
     if { $photo_name == "" || ![lb]file exists $path/$photo_name[rb] } {
       continue
     }

     # Save image file size
     set photo_size [lb]file size $path/$photo_name[rb]

     # Create new record in photo table
     ossweb::db::insert photo \
          -error t
   }

   ossweb::conn::set_msg "Pictures have been uploaded"
   ossweb::conn::next cmd edit tab upload
}

# Album details callback
ossweb::conn::callback edit {} {

   # New album, do nothing
   if { $album_id == "" } {
     return
   }

   # Read album record by album_id
   if { [lb]ossweb::db::read album album_id[rb] } {

     error "OSSWEB: Invalid album id $album_id"
   }

   # Perform tab-specific actions
   switch -- $tab {
    photos {

       # Retrieve all pictures for given album
       ossweb::db::read photos -type "multirow photos" album_id $album_id -eval {

         # Make file size human readable
         set row(photo_size) [lb]ossweb::util::size $row(photo_size)[rb]

         # Assign with link to open new window with full picture
         set row(photo_url) [lb]ossweb::html::link -image /photo/$row(photo_name) -url $row(photo_name) \
                                  -width 150 \
                                  -height 150 \
                                  -window Photo[rb]

       }

    }

    default {

       # Update album mode, change command to update
       ossweb::widget form_album.cmd -label Update

       # If out album, define delete button
       if { $user_id == [lb]ossweb::conn user_id[rb] } {

         ossweb::widget form_album.delete -type button -label Delete \
              -confirmtext "Album will be deleted, continue?" \
              -url "cmd delete album_id $album_id"
       }

       # Update form with values fromTcl variables
       ossweb::form form_album set_values

    }
   }
}

# Form definition for album
ossweb::conn::callback create_form_album {} {

   ossweb::form form_album -title "Album Details"

   ossweb::widget form_album.album_id -type hidden \
        -datatype int \
        -optional

   ossweb::widget form_album.album_name -label Name

   ossweb::widget form_album.album_descr -type textarea -label Description \
        -resize \
        -cols 50 \
        -rows 2 \
        -optional

   ossweb::widget form_album.cmd -type submit -label Create

   ossweb::widget form_album.back -type button -label Back \
        -url "cmd view"
}

# Form definition for uploading pictures
ossweb::conn::callback create_form_upload {} {

   ossweb::form form_upload -title "Upload Pictures"

   ossweb::widget form_upload.album_id -type hidden -datatype int

   ossweb::widget form_upload.file1 -type file -label Picture1

   ossweb::widget form_upload.file2 -type file -label Picture2 \
        -optional

   ossweb::widget form_upload.file3 -type file -label Picture3 \
        -optional

   ossweb::widget form_upload.file4 -type file -label Picture4 \
        -optional

   ossweb::widget form_upload.file5 -type file -label Picture5 \
        -optional

   ossweb::widget form_upload.cmd -type submit -label Upload
}

# Form definition for tabs
ossweb::conn::callback create_form_tab {} {

   ossweb::form form_tab

   # For new albums do not show tabs
   if { $album_id == "" } {
     return
   }

   set url "cmd edit album_id $album_id"

   ossweb::form form_tab -widgets {
        { details -type link -label Details -url $url }
        { upload -type link -label Upload -url $url }
        { photos -type link -label Photos -url $url }
   }
}

# Call request controller, create specified forms, declare variables
# and perform request routing depending on command
ossweb::conn::process \
     -columns { album_id int ""
                tab "" ""
                user_id userid 0 } \
     -forms { form_album form_tab form_upload } \
     -default view

[example_end]

We start from the bottom, -forms parameter now include 3 forms to be created on page
invocation. There are ways to distiguish when to create any particular form but for the first
tutorial we will make this simple. We create all forms and but in only one case, when we need to
create new album we destroy form_tab form so tabs will not show with empty form.

[para]

form_tab for is used for generating tabs, there are different styles of tabs in the OSSWEB, for this
example we will use default. To try and see how it look, try to set <formtab id=form_tab style=blue> or
any other styles from the list: [emph {text ebay square oval oval2}].

[para]

Another form is form_upload, we will use it for uploading puctures into our album. We defined 5 inputs,
first one is required but other are optional. When this form is submitted, it will use upload command as
defined by Upload button.

[para]
Callback edit has been changed as well, now we have to handle different tabs, so we use switch on Tcl
variable tab to produce different data for different parts of ADP template.

When tab photos was chosen, we retrieve all pictures for the selected album into multirow
datasource or recordset.

[para]
photo_size field is updated with human readable format of the image size. We assign every image with
link to popup separate window whcih will show image in full size. In the page we scale them to 150x150,
some images will be distored but in this application we will not perform smart scaling using ImageMagick or
with other conversion tool.

[para]

New callback upload has been created as well, it will handle upload command:
save pictures and create records in photo table for each uploaded picture. Pictures will
be saved in the same directory where our pages reside. There is another mechanism to
save picturs out of web server root so it cannot be accessed directly. For public
albums this is not very useful and a little bit more complicated.
When we save picture name in the table we will get the size of the image file and store it in
the table, just for convenience for not checking file size on every view.

[section {OSSWEB API}]

[subsection {Namespace Hierarchy}]

OSSWEB API logically split into different Tcl namespace which provides
clean way of separation and allows keeping related function close to each other
instead of spreading the login across the whole system.

[para]

The hierachy tree looks like this:

[list_begin itemized]

[item] [emph ossweb]
[list_begin itemized]
[item] [emph admin] - Administrative procs
[item] [emph control] - Controlling/extending and customization hadlers

   [list_begin itemized]
   [item] [emph user] - Extending users modifications
   [item] [emph prefs] - Extending user preferences
   [item] [emph login] - Customize user login process
   [item] [emph logout] - Customize user logout process
   [item] [emph nosession] - Customize redirection for not logged in users
   [item] [emph noaccess] - Customize redirection for access denied situation
   [list_end]
   [para]

[item] [emph tag] - Custom templating tags
[item] [emph html] - HTML generation procs

   [list_begin itemized]
   [item] [emph menu] - Different navigation menus
   [item] [emph toolbar] - Support for modules toolbar
   [list_end]
   [para]

[item] [emph cache] - local cache procs
[item] [emph datatype] - data type validation
[item] [emph cluster] - multi server cluster support
[item] [emph adp] - templating engine
[item] [emph schedule] - background scheduling

  [list_begin itemized]
  [item] [emph hourly] - All Tcl procs in this namespace will be run every hour
  [item] [emph daily] - All Tcl procs in this namespace will be run every day
  [item] [emph weekly] - All Tcl procs in this namespace will be run every week
  [item] [emph monthly] - All Tcl procs in this namespace will be run every month
  [list_end]
  [para]

[item] [emph conn] - Current connection/session support
[item] [emph tsearch] - Full text search support
[item] [emph tracker] - Update tracker support
[item] [emph sql] - SQL generation support
[item] [emph db] - Database API procs
[item] [emph util] - Misc utilities
[item] [emph convert] - Convertion between different types
[item] [emph form] - Form validation/support
[item] [emph widget] - Widget support, form generation
[item] [emph file] - File storage support
[item] [emph resource] - Resource sharing and locking
[item] [emph lookup] - Lookup/search support
[list_end]
[list_end]

[subsection {Core Procs}]

[list_begin itemized]

[item] [cmd ossweb::register_init] [arg name]

[para]
[item] [cmd ossweb::random]

[para]
[item] [cmd ossweb::random_range] [opt [arg {range 100}]]

[para]
[item] [cmd ossweb::version] [opt [arg -module]] [opt [arg {-rev f}]]

[para]
[item] [cmd ossweb::config] [arg param] [opt [arg default]]

[para]
[item] [cmd ossweb::set_config] [arg name] [opt [arg value]] [opt [arg {db 0}]]

[para]
[item] [cmd ossweb::list_config] [arg pattern]

[para]
[item] [cmd ossweb::reset_config] [opt [arg {-cluster f}]]

[para]
[item] [cmd ossweb::exists] [arg name]

[para]
[item] [cmd ossweb::lexists] [arg list] [arg value]

[para]
[item] [cmd ossweb::image_name] [arg name]

[para]
[item] [cmd ossweb::image_exists] [arg id] [opt [arg path]] [opt [arg root]]

[para]
[item] [cmd ossweb::decode] [arg value] [opt [arg args]]

[para]
[item] [cmd ossweb::iftrue] [arg if] [arg then] [opt [arg else]]

[para]
[item] [cmd ossweb::nvl] [arg value] [opt [arg default]]

[para]
[item] [cmd ossweb::true] [arg value] [opt [arg {null 0}]]

[para]
[item] [cmd ossweb::coalesce] [arg val1] [opt [arg val2]] [opt [arg valN...]]

[para]
[item] [cmd ossweb::message] [arg type]

[para]
[item] [cmd ossweb::hexify] [arg data]

[para]
[item] [cmd ossweb::dehexify] [arg data]

[para]
[item] [cmd ossweb::pad0] [arg string] [arg size]

[para]
[item] [cmd ossweb::trim0] [arg value]

[para]
[item] [cmd ossweb::dirname] [arg path]

[para]
[item] [cmd ossweb::negative] [arg value]

[para]
[item] [cmd ossweb::file_list] [arg path] [arg match]

[para]
[item] [cmd ossweb::number_list] [arg last] [opt [arg {first 0}]]

[para]
[item] [cmd ossweb::option_list] [arg first] [arg last] [opt [arg {step 1}]] [opt [arg {size 0}]]

[para]
[item] [cmd ossweb::read_file] [arg path]

[para]
[item] [cmd ossweb::write_file] [arg path] [arg data] [opt [arg {-empty t}]] [opt [arg {-mode w}]]

[para]
[item] [cmd ossweb::oproc] [arg nm] [arg proc] [arg params] [opt [arg default]]

[para]
[item] [cmd ossweb::ovar] [arg nm] [arg var] [opt [arg default]]

[para]
[item] [cmd ossweb::template] [arg name] [opt [arg -level]]

[para]
[item] [cmd ossweb::encrypt] [arg str] [opt [arg -secret]] [opt [arg -token]]

[para]
[item] [cmd ossweb::decrypt] [arg str] [opt [arg -secret]] [opt [arg -token]] [opt [arg -crc]]

[para]
[item] [cmd ossweb::crc32] [arg instr]

[para]
[item] [cmd ossweb::acl] [arg acl]

[para]
[item] [cmd ossweb::date] [arg command]

[para]
[item] [cmd ossweb::sendmail] [arg rcpt_to] [arg mail_from] [arg subject] [arg body]
                             [opt [arg -headers]]
                             [opt [arg -domain]]
                             [opt [arg -files]]
                             [opt [arg -direct]]
                             [opt [arg -bcc]]
                             [opt [arg -cc]]
                             [opt [arg -error]]
                             [opt [arg -message_type]]
                             [opt [arg -content_type]]
                             [opt [arg -filedir]]

[para]
[item] [cmd ossweb::multirow] [arg cmd]

[para]
[item] [cmd ossweb::project] [arg name] [opt [arg default]]

[para]
[item] [cmd ossweb::tsearch] [arg cmd] [arg type]

[list_end]

[para]

[subsection {Cache Procs}]

[list_begin itemized]

[item] [cmd ossweb::cache] [arg command] [arg key]

[para]
[item] [cmd ossweb::cache::create] [arg cache] [opt [arg -params]] [opt [arg -expires]] [opt [arg {-size 0}]] [opt [arg -timeout]] [opt [arg -maxentry]]

[para]
[item] [cmd ossweb::cache::exists] [arg cache] [arg key]

[para]
[item] [cmd ossweb::cache::put] [arg cache] [arg key] [arg val] [opt [arg -params]] [opt [arg -expires]] [opt [arg -timeout]]

[para]
[item] [cmd ossweb::cache::run] [arg cache] [arg key] [arg script] [opt [arg -force]] [opt [arg -params]] [opt [arg -expires]] [opt [arg -timeout]]

[para]
[item] [cmd ossweb::cache::get] [arg cache] [arg key] [opt [arg -params]] [opt [arg -default]] [opt [arg -timeout]]

[para]
[item] [cmd ossweb::cache::incr] [arg cache] [arg key] [opt [arg -params]] [opt [arg {-incr 1}]] [opt [arg -expires]] [opt [arg -timeout]]

[para]
[item] [cmd ossweb::cache::append] [arg cache] [arg key] [arg val] [opt [arg -params]] [opt [arg -expires]] [opt [arg -timeout]]

[para]
[item] [cmd ossweb::cache::lappend] [arg cache] [arg key] [arg val] [opt [arg -params]] [opt [arg -expires]] [opt [arg -timeout]]

[para]
[item] [cmd ossweb::cache::flush] [arg cache]

[para]
[item] [cmd ossweb::cache::keys] [arg cache] [opt [arg pattern]]

[para]
[item] [cmd ossweb::cache::names]

[list_end]

[para]

[subsection {Type Validation Procs}]

[list_begin itemized]

[item] [cmd ossweb::datatype::validate] [arg name] [arg type] [opt [arg -code]] [opt [arg -errmsg]] [opt [arg -level]] [opt [arg {-required 1}]]

[para]
[item] [cmd ossweb::datatype::value] [arg name] [arg type] [opt [arg -default]] [opt [arg {-level 1}]]

[para]
[item] [cmd ossweb::datatype::integer] [arg value]

[para]
[item] [cmd ossweb::datatype::int] [arg value]

[para]
[item] [cmd ossweb::datatype::ilist] [arg value]

[para]
[item] [cmd ossweb::datatype::text] [arg value]

[para]
[item] [cmd ossweb::datatype::textarea] [arg value]

[para]
[item] [cmd ossweb::datatype::url] [arg value]

[para]
[item] [cmd ossweb::datatype::name] [arg value]

[para]
[item] [cmd ossweb::datatype::file] [arg value]

[para]
[item] [cmd ossweb::datatype::email] [arg value]

[para]
[item] [cmd ossweb::datatype::float] [arg value]

[para]
[item] [cmd ossweb::datatype::money] [arg value]

[para]
[item] [cmd ossweb::datatype::macaddr] [arg value]

[para]
[item] [cmd ossweb::datatype::ipaddr] [arg value]

[para]
[item] [cmd ossweb::datatype::phone] [arg value]

[para]
[item] [cmd ossweb::datatype::boolean] [arg value]

[list_end]

[para]

[subsection {Conversion Procs}]

[list_begin itemized]

[item] [cmd ossweb::convert::string_to_list] [arg str] [opt [arg -skip]] [opt [arg {-separator " "}]]

[para]
[item] [cmd ossweb::convert::set_to_list] [arg id] [opt [arg -skip]] [opt [arg {-values f}]] [opt [arg {-names f}]] [opt [arg -filter]] [opt [arg {-lowercase f}]]

[para]
[item] [cmd ossweb::convert::set_to_attributes] [opt [arg -skip]] [opt [arg -quotes]] [opt [arg -filter]]

[para]
[item] [cmd ossweb::convert::set_to_vars] [arg id] [opt [arg -skip]] [opt [arg {-level 1}]]

[para]
[item] [cmd ossweb::convert::set_to_array] [arg id] [arg name] [opt [arg -skip]] [opt [arg -filter]]

[para]
[item] [cmd ossweb::convert::list_to_query] [arg list]

[para]
[item] [cmd ossweb::convert::list_to_attributes] [arg list] [opt [arg -skip]] [opt [arg {-quote """}]] [opt [arg {-delim " "}]]

[para]
[item] [cmd ossweb::convert::list_to_array] [arg list] [arg name]

[para]
[item] [cmd ossweb::convert::list_to_vars] [arg list] [opt [arg {-null t}]] [opt [arg {-level 1}]] [opt [arg -skip]]

[para]
[item] [cmd ossweb::convert::vars_to_list] [arg vars] [opt [arg {-null t}]] [opt [arg {-level 1}]] [opt [arg -skip]]

[para]
[item] [cmd ossweb::convert::array_to_set] [arg array] [opt [arg {-persist f}]] [opt [arg -name]]

[para]
[item] [cmd ossweb::convert::array_to_list] [arg array] [opt [arg -skip]] [opt [arg -filter]]

[para]
[item] [cmd ossweb::convert::array_to_string] [arg array] [opt [arg {-delimiter ","}]] [opt [arg {-escape f}]] [opt [arg {-quote f}]]

[para]
[item] [cmd ossweb::convert::array_to_js] [arg array]

[para]
[item] [cmd ossweb::convert::plain_list] [arg name]

[para]
[item] [cmd ossweb::convert::query_to_vars] [arg str]

[para]
[item] [cmd ossweb::convert::query_to_value] [arg value] [opt [arg type]]

[para]
[item] [cmd ossweb::convert::value_to_query] [arg value] [opt [arg type]]

[list_end]

[para]

[subsection {Connection Procs}]

[list_begin itemized]

[item] [cmd ossweb::conn] [arg name] [opt [arg args]]

[para]
[item] [cmd ossweb::conn::log] [arg type] [arg name] [opt [arg args]]

[para]
[item] [cmd ossweb::conn::init_vars] [opt [arg -level]] [opt [arg {-force f}]] [opt [arg -skip]] [opt [arg -array]] [arg columns]

[para]
[item] [cmd ossweb::conn::init_reftable] [opt [arg -page_name]] [opt [arg -app_name]]

[para]
[item] [cmd ossweb::conn::export_form] [opt [arg -form]] [opt [arg -include]] [opt [arg -skip]] [opt [arg -format]]

[para]
[item] [cmd ossweb::conn::get_property] [arg name] [opt [arg {-global f}]]
                                                  [opt [arg {-cache t}]]
                                                  [opt [arg -default]]
                                                  [opt [arg -columns]]
                                                  [opt [arg -array]]
                                                  [opt [arg -skip]]
                                                  [opt [arg {-db t}]]
                                                  [opt [arg {-debug f}]]
                                                  [opt [arg -timeout]]
                                                  [opt [arg {-encrypt f}]]
                                                  [opt [arg {-decrypt f}]]
                                                  [opt [arg -user_id]]

[para]
[item] [cmd ossweb::conn::set_property] [arg name] [arg value]
                                       [opt [arg {-global f}]]
                                       [opt [arg {-cache t}]]
                                       [opt [arg -columns]]
                                       [opt [arg -array]]
                                       [opt [arg -vars]]
                                       [opt [arg -forms]]
                                       [opt [arg -skip]]
                                       [opt [arg {-db t}]]
                                       [opt [arg {-debug f}]]
                                       [opt [arg {-append f}]]
                                       [opt [arg {-lappend f}]]
                                       [opt [arg -timeout]]
                                       [opt [arg {-encrypt f}]]
                                       [opt [arg {-decrypt f}]]
                                       [opt [arg -user_id]]

[para]
[item] [cmd ossweb::conn::clear_property] [arg name] [opt [arg {-global f}]] [opt [arg {-cache f}]] [opt [arg {-db t}]] [opt [arg -user_id]]

[para]
[item] [cmd ossweb::conn::sessionvars] [opt [arg -level]] [opt [arg {-global f}]] [opt [arg {-clear f}]] [opt [arg {-query t}]] [opt [arg {-debug f}]] [opt [arg args]]

[para]
[item] [cmd ossweb::conn::query] [opt [arg {-quote f}]]
                   [opt [arg -level]]
                   [opt [arg {-return f}]]
                   [opt [arg -regexp]]
                   [opt [arg -match]]
                   [opt [arg -columns]]
                   [opt [arg -form]]
                   [opt [arg {-validate t}]]
                   [opt [arg {-plain f}]]
                   [opt [arg -array]]
                   [opt [arg {-debug f}]]

[para]
[item] [cmd ossweb::conn::callback] [arg name] [arg body]

[para]
[item] [cmd ossweb::conn::response] [opt [arg data]] [opt [arg {type text/html}]]

[para]
[item] [cmd ossweb::conn::next] [opt [arg -project_name]]
                   [opt [arg -app_name]]
                   [opt [arg -page_name]]
                   [opt [arg {-cmd_name view}]]
                   [opt [arg -ctx_name]]
                   [opt [arg -app]]
                   [opt [arg -page]]
                   [opt [arg -cmd]]
                   [opt [arg -ctx]]
                   [opt [arg {-exit ?}]]
                   [opt [arg -javascript]]
                   [opt [arg -errormsg]]
                   [opt [arg -target]]
                   [opt [arg {-return f}]]
                   [opt [arg -url]]
                   [opt [arg {-debug f}]]
                   [opt [arg {-none f}]]
                   [opt [arg args]]

[para]
[item] [cmd ossweb::conn::process] [opt [arg -columns]]
                   [opt [arg -columns2]]
                   [opt [arg -sessionvars]]
                   [opt [arg {-sessionvars_clear f}]]
                   [opt [arg {-sessionvars_global f}]]
                   [opt [arg -next]]
                   [opt [arg -next_template]]
                   [opt [arg {-on_error_set_msg "Application was unable to process the request"}]]
                   [opt [arg {-on_error_set_cmd edit}]]
                   [opt [arg {-on_error {-cmd error}}]]
                   [opt [arg -on_error_set_template]]
                   [opt [arg -on_error_eval]]
                   [opt [arg {-transaction f}]]
                   [opt [arg -validate]]
                   [opt [arg -sql_stmt]]
                   [opt [arg -forms]]
                   [opt [arg {-form_error f}]]
                   [opt [arg -form_validate]]
                   [opt [arg -form_create]]
                   [opt [arg {-form_recreate f}]]
                   [opt [arg {-form_tracking f}]]
                   [opt [arg {-form_tracking_clear f}]]
                   [opt [arg {-query f}]]
                   [opt [arg -queryarray]]
                   [opt [arg -exec]]
                   [opt [arg {-debug f}]]
                   [opt [arg -final]]
                   [opt [arg -default]]
                   [opt [arg -eval]]

[para]
[item] [cmd ossweb::conn::set_user_id] [opt [arg -domain]]
                   [opt [arg -cookie ]]
                   [opt [arg {-max_age -1}]]
                   [opt [arg {-path /}]]
                   [opt [arg {-secure f}]]
                   [opt [arg {-clear f}]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::conn::set_session_id] [opt [arg -max_age]]
                   [opt [arg -domain]]
                   [opt [arg -cookie]]
                   [opt [arg {-secure f}]]
                   [opt [arg {-path /}]]
                   [opt [arg {-new f}]]
                   [opt [arg {-clear f}]]
                   [opt [arg -data]]
                   [opt [arg -session]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::conn::redirect] [arg url] [opt [arg {-exit t}]] [opt [arg {-log f}]]

[para]
[item] [cmd ossweb::conn::redirect_for_login] [opt [arg -url]] [opt [arg {-redirect t}]] [opt [arg {-callbacks t}]]

[para]
[item] [cmd ossweb::conn::redirect_access_denied] [opt [arg {-msg accessdenied}]]

[para]
[item] [cmd ossweb::conn::sign] [opt [arg -max_age]] [arg value]

[para]
[item] [cmd ossweb::conn::signed_cookie] [opt [arg {-set_expires f}]] [arg name]

[para]
[item] [cmd ossweb::conn::sign_cookie] [opt [arg {-secure 0}]] [opt [arg -max_age]] [opt [arg -domain]] [opt [arg -path]] [arg name] [arg value]

[para]
[item] [cmd ossweb::conn::parse_url]

[para]
[item] [cmd ossweb::conn::parse_user] [opt [arg cookie]]

[para]
[item] [cmd ossweb::conn::parse_session] [arg user_id] [opt [arg -cookie]] [opt [arg -check_ip]]

[para]
[item] [cmd ossweb::conn::parse_request]


[para]
[item] [cmd ossweb::conn::read_user] [arg user_id]
                                    [opt [arg -user_name]]
                                    [opt [arg -user_email]]
                                    [opt [arg -check_password]]
                                    [opt [arg -cache]]
                                    [opt [arg {-refresh f}]]
                                    [opt [arg {-timeout 900}]]

[para]
[item] [cmd ossweb::conn::read_acl] [arg obj_id]

[para]
[item] [cmd ossweb::conn::check_acl] [opt [arg -acl]]
                   [opt [arg -project_name]]
                   [opt [arg -app_name]]
                   [opt [arg -page_name]]
                   [opt [arg -cmd_name]]
                   [opt [arg -ctx_name]]
                   [opt [arg {-query N}]]
                   [opt [arg {-handlers N}]]
                   [opt [arg -params]]
                   [opt [arg {-unknown unknown}]]
                   [opt [arg {-debug f}]]

[para]
[item] [cmd ossweb::conn::create_acl] [arg obj_id]
                   [opt [arg -project_name]]
                   [opt [arg {-app_name *}]]
                   [opt [arg {-page_name *}]]
                   [opt [arg {-cmd_name *}]]
                   [opt [arg {-ctx_name *}]]
                   [opt [arg {-value Y}]]
                   [opt [arg -query]]
                   [opt [arg -handlers]]
                   [opt [arg -precedence]]
                   [opt [arg {-obj_type U}]]

[para]
[item] [cmd ossweb::conn::shared_secret]

[para]
[item] [cmd ossweb::conn::secret] [arg seed]

[para]
[item] [cmd ossweb::conn::set_msg] [opt [arg -color]] [opt [arg {-standard f}]] [opt [arg {-new f}]] [arg msg]

[para]
[item] [cmd ossweb::conn::header] [arg name]

[para]
[item] [cmd ossweb::conn::hostname] [opt [arg {proto "http://"}]]

[para]
[item] [cmd ossweb::conn::localnetwork] [opt [arg ipaddr]]

[list_end]

[para]

[subsection {Database Procs}]

[list_begin itemized]

[item] [cmd ossweb::db::xql] [arg data] [opt [arg level]] [opt [arg vars]] [opt [arg varray]]

[para]
[item] [cmd ossweb::db::columns] [arg table_name] [opt [arg {attnum 0}]]

[para]
[item] [cmd ossweb::db::tables] [opt [arg -tables]]

[para]
[item] [cmd ossweb::db::value] [arg sql]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg {-release f}]]
                   [opt [arg -default]]
                   [opt [arg {-refresh f}]]
                   [opt [arg -cache]]
                   [opt [arg {-cache:auto f}]]
                   [opt [arg -cache:flush]]
                   [opt [arg -timeout]]
                   [opt [arg {-debug f}]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg -colname]]
                   [opt [arg {-colindex 0}]]
                   [opt [arg -map]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::list] [arg sql]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg {-refresh f}]]
                   [opt [arg {-debug f}]]
                   [opt [arg -cache]]
                   [opt [arg {-cache:auto f}]]
                   [opt [arg -cache:flush]]
                   [opt [arg {-colindex 0}]]
                   [opt [arg -colname]]
                   [opt [arg -timeout]]
                   [opt [arg {-release f}]]
                   [opt [arg -maxrows]]
                   [opt [arg {-unique f}]]
                   [opt [arg {-all f}]]
                   [opt [arg -map]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::multilist] [arg sql]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg {-refresh f}]]
                   [opt [arg {-debug f}]]
                   [opt [arg -cache]]
                   [opt [arg {-cache:auto f}]]
                   [opt [arg -cache:flush]]
                   [opt [arg -timeout]]
                   [opt [arg {-release f}]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg {-array f}]]
                   [opt [arg {-plain f}]]
                   [opt [arg -acl]]
                   [opt [arg -map]]
                   [opt [arg -unique]]
                   [opt [arg -maxrows]]
                   [opt [arg -arrayvars]]
                   [opt [arg -colcount]]
                   [opt [arg -colindex]]
                   [opt [arg -colname]]

[para]
[item] [cmd ossweb::db::multivalue] [arg sql]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg -prefix]]
                   [opt [arg {-refresh f}]]
                   [opt [arg {-error f}]]
                   [opt [arg -array]]
                   [opt [arg -cache]]
                   [opt [arg {-cache:auto f}]]
                   [opt [arg -cache:flush]]
                   [opt [arg -timeout]]
                   [opt [arg {-release f}]]
                   [opt [arg {-debug f}]]
                   [opt [arg {-local t}]]
                   [opt [arg -map]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg -arrayvars]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::multirow] [arg name] [arg sql]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg -eval]]
                   [opt [arg -eval2]]
                   [opt [arg {-local f}]]
                   [opt [arg -replace_null]]
                   [opt [arg -set_null]]
                   [opt [arg {-refresh f}]]
                   [opt [arg {-debug f}]]
                   [opt [arg -cache]]
                   [opt [arg {-cache:auto f}]]
                   [opt [arg -cache:flush]]
                   [opt [arg {-cache:global t}]]
                   [opt [arg {-norows f}]]
                   [opt [arg {-nocolumns f}]]
                   [opt [arg {-maxrows 1000}]]
                   [opt [arg -timeout]]
                   [opt [arg {-error f}]]
                   [opt [arg {-release f}]]
                   [opt [arg -map]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg -arrayvars]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::multipage] [arg id] [arg query1] [arg query2]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg {-debug f}]]
                   [opt [arg -eval]]
                   [opt [arg -cache]]
                   [opt [arg {-refresh f}]]
                   [opt [arg -eval2]]
                   [opt [arg -query]]
                   [opt [arg -url]]
                   [opt [arg -eval_single]]
                   [opt [arg -replace_null]]
                   [opt [arg -set_null]]
                   [opt [arg {-pagesize 25}]]
                   [opt [arg {-timeout 600}]]
                   [opt [arg {-page 1}]]
                   [opt [arg {-local f}]]
                   [opt [arg {-force f}]]
                   [opt [arg {-cmd cmd}]]
                   [opt [arg {-cmd_name view}]]
                   [opt [arg {-error f}]]
                   [opt [arg {-datatype int}]]
                   [opt [arg {-release f}]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg -map]]
                   [opt [arg -arrayvars]]
                   [opt [arg {-norows f}]]
                   [opt [arg -user_id]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::foreach] [arg sql]
                   [opt [arg -eval}]]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg {-release f}]]
                   [opt [arg -prefix]]
                   [opt [arg -columns]]
                   [opt [arg -on_empty]]
                   [opt [arg {-error f}]]
                   [opt [arg {-debug f}]]
                   [opt [arg {-refresh f}]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg -cache]]
                   [opt [arg {-cache:auto f}]]
                   [opt [arg -cache:flush]]
                   [opt [arg -arrayvars]]
                   [opt [arg -array]]
                   [opt [arg -map]]
                   [opt [arg -timeout]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::exec] [arg sql]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg {-error f}]]
                   [opt [arg {-debug f}]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg -cmd]]
                   [opt [arg {-msg f}]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::insert] [arg table]
                   [opt [arg -insertargs]]
                   [opt [arg {-skip_null t}]]
                   [opt [arg -skip]]
                   [opt [arg -columns]]
                   [opt args]

[para]
[item] [cmd ossweb::db::update] [arg table]
                   [opt [arg -where]]
                   [opt [arg -dbargs]]
                   [opt [arg -updateargs]]
                   [opt [arg {-skip_null f}]]
                   [opt [arg -skip]]
                   [opt [arg -columns]]
                   [opt args]

[para]
[item] [cmd ossweb::db::delete] [arg table]
                   [opt [arg -where]]
                   [opt [arg -dbargs]]
                   [opt args]

[para]
[item] [cmd ossweb::db::read] [arg table]
                   [opt [arg -where]]
                   [opt [arg -dbargs]]
                   [opt [arg {-type multivalue}]]
                   [opt [arg {-columns *}]]
                   [opt [arg -filter]]
                   [opt [arg -filterargs]]
                   [opt [arg -orderby]]
                   [opt [arg -limit]]
                   [opt args]

[para]
[item] [cmd ossweb::db::select] [arg table]
                   [opt [arg -where]]
                   [opt [arg -dbargs]]
                   [opt [arg {-type multilist}]]
                   [opt [arg {-columns *}]]
                   [opt [arg -filter]]
                   [opt [arg -filterargs]]
                   [opt [arg -orderby]]
                   [opt [arg -limit]]
                   [opt args]

[para]
[item] [cmd ossweb::db::block] [arg sql_list]
                   [opt [arg -level]]
                   [opt [arg -db]]
                   [opt [arg {-release f}]]
                   [opt [arg -vars]]
                   [opt [arg -vars:array]]
                   [opt [arg {-debug f}]]
                   [opt [arg -acl]]

[para]
[item] [cmd ossweb::db::handle] [opt [arg pool]] [opt [arg {count 1}]]

[para]
[item] [cmd ossweb::db::sethandle] [arg db]

[para]
[item] [cmd ossweb::db::release]

[para]
[item] [cmd ossweb::db::cache] [arg cmd]  [arg name]  [opt [arg value]]

[para]
[item] [cmd ossweb::db::begin] [opt [arg -db]]

[para]
[item] [cmd ossweb::db::commit] [opt [arg -db]]

[para]
[item] [cmd ossweb::db::rollback] [opt [arg -db]]

[para]
[item] [cmd ossweb::db::rowcount] [opt [arg -db]]

[para]
[item] [cmd ossweb::db::parse_error] [arg errmsg] [opt [arg sql]] [opt [arg id]]

[para]
[item] [cmd ossweb::db::nextval] [opt [arg {name ossweb_util}]]

[para]
[item] [cmd ossweb::db::currval] [opt [arg {name ossweb_util}]]

[para]
[item] [cmd ossweb::db::vars] [arg cmd] [arg level] [opt [arg vars]] [opt [arg varray]]

[list_end]

[para]

[subsection {SQL Support Procs}]

[list_begin itemized]

[item] [cmd ossweb::sql::ignore] [arg type]

[para]
[item] [cmd ossweb::sql::dbargs] [arg params]

[para]
[item] [cmd ossweb::sql::columns] [arg table_name] [opt [arg args]]

[para]
[item] [cmd ossweb::sql::insert_values] [opt [arg {-full f}]]
                   [opt [arg -skip]]
                   [opt [arg -mask]]
                   [opt [arg -prefix]]
                   [opt [arg -array]]
                   [opt [arg -columns2]]
                   [opt [arg {-skip_null f}]]
                   [opt [arg {-level 1}]]
                   [opt [arg -nl]]
                   [opt [arg -map]]
                   [arg columns]

[para]
[item] [cmd ossweb::sql::update_values] [opt [arg -mask]]
                   [opt [arg -map]]
                   [opt [arg -prefix]]
                   [opt [arg -array]]
                   [opt [arg -columns2]]
                   [opt [arg -skip]]
                   [opt [arg {-skip_null f}]]
                   [opt [arg -keep]]
                   [opt [arg {-level 1}]]
                   [opt [arg {-debug f}]]
                   [arg columns]

[para]
[item] [cmd ossweb::sql::filter] [arg columns] [opt [arg -skip]]
                   [opt [arg -alias]]
                   [opt [arg -before]]
                   [opt [arg -after]]
                   [opt [arg -where]]
                   [opt [arg {-filter NULL}]]
                   [opt [arg -custom]]
                   [opt [arg -map]]
                   [opt [arg -embed]]
                   [opt [arg -array]]
                   [opt [arg -aliasmap]]
                   [opt [arg {-level 1}]]
                   [opt [arg {-single f}]]
                   [opt [arg -namemap]]
                   [opt [arg -nullmap]]
                   [opt [arg {-and AND}]]
                   [opt [arg -prefix]]

[para]
[item] [cmd ossweb::sql::list] [arg lst] [opt [arg type]]

[para]
[item] [cmd ossweb::sql::quote] [arg value] [opt [arg type]]

[para]
[item] [cmd ossweb::sql::multipage] [arg id]
                   [opt [arg -level]]
                   [opt [arg -ids]]
                   [opt [arg {-flush f}]]
                   [opt [arg -return]]
                   [opt [arg -user_id]]
                   [opt [arg {-page 1}]]
                   [opt [arg {-cmd cmd}]]
                   [opt [arg {-cmd_name page}]]
                   [opt [arg {-pagesize 30}]]
                   [opt [arg -query]]
                   [opt [arg -url]]
                   [opt [arg -cache]]
                   [opt [arg {-timeout 600}]]

[list_end]

[para]

[subsection {Forms and Widget Procs}]

[list_begin itemized]

[item] [cmd ossweb::form] [arg id] [opt [arg command]] [opt [arg args]]

[para]
[item] [cmd ossweb::widget] [arg id] [arg command] [opt [arg args]]

[para]
[item] [cmd ossweb::widget::none]

[para]
[item] [cmd ossweb::widget::date]

[para]
[item] [cmd ossweb::widget::calendar]

[para]
[item] [cmd ossweb::widget::inform]

[para]
[item] [cmd ossweb::widget::readonly]

[para]
[item] [cmd ossweb::widget::label]

[para]
[item] [cmd ossweb::widget::link]

[para]
[item] [cmd ossweb::widget::sorting]

[para]
[item] [cmd ossweb::widget::text]

[para]
[item] [cmd ossweb::widget::textarea]

[para]
[item] [cmd ossweb::widget::file]

[para]
[item] [cmd ossweb::widget::filelink]

[para]
[item] [cmd ossweb::widget::hidden]

[para]
[item] [cmd ossweb::widget::password]

[para]
[item] [cmd ossweb::widget::image]

[para]
[item] [cmd ossweb::widget::button]

[para]
[item] [cmd ossweb::widget::submit]

[para]
[item] [cmd ossweb::widget::reset]

[para]
[item] [cmd ossweb::widget::checkbox]

[para]
[item] [cmd ossweb::widget::radio]

[para]
[item] [cmd ossweb::widget::helpbutton]

[para]
[item] [cmd ossweb::widget::boolean]

[para]
[item] [cmd ossweb::widget::howto]

[para]
[item] [cmd ossweb::widget::select]

[para]
[item] [cmd ossweb::widget::combobox]

[para]
[item] [cmd ossweb::widget::popupbutton]

[para]
[item] [cmd ossweb::widget::popuptext]

[para]
[item] [cmd ossweb::widget::multiselect]

[para]
[item] [cmd ossweb::widget::labelselect]

[para]
[item] [cmd ossweb::widget::lookup]

[para]
[item] [cmd ossweb::widget::user_lookup]

[para]
[item] [cmd ossweb::widget::email_lookup]

[para]
[item] [cmd ossweb::widget::employee_lookup]

[para]
[item] [cmd ossweb::widget::imageselect]

[para]
[item] [cmd ossweb::widget::soundselect]

[para]
[item] [cmd ossweb::widget::reminder]

[para]
[item] [cmd ossweb::widget::webtracking]

[para]
[item] [cmd ossweb::widget::userselect]

[para]
[item] [cmd ossweb::widget::groupselect]

[para]
[item] [cmd ossweb::widget::categoryselect]

[para]
[item] [cmd ossweb::widget::numberselect]

[para]
[item] [cmd ossweb::widget::intervalselect]

[para]
[item] [cmd ossweb::widget::colorselect]

[list_end]

[para]

[subsection {HTML Procs}]

[list_begin itemized]

[item] [cmd ossweb::html::url]
                   [opt [arg -url]]
                   [opt [arg -path]]
                   [opt [arg {-proto "http://"}]]
                   [opt [arg -query]]
                   [opt [arg {-host f}]]
                   [opt [arg -confirm]]
                   [opt [arg -confirmtext]]
                   [opt [arg -list]]
                   [opt [arg -extension]]
                   [opt [arg -project_name]]
                   [opt [arg -app_name]]
                   [opt [arg -page_name]]
                   [opt [arg -hash]]
                   [opt [arg {-popup f}]]
                   [opt [arg -popupdnd]]
                   [opt [arg -popupsync]]
                   [opt [arg -popupname]]
                   [opt [arg -popupshow]]
                   [opt [arg -popupdata]]
                   [opt [arg -popupdataobj]]
                   [opt [arg -popuptop]]
                   [opt [arg -popupleft]]
                   [opt [arg -popupwidth]]
                   [opt [arg -popupheight]]
                   [opt [arg -popupbgcolor]]
                   [opt [arg -popupborder]]
                   [opt [arg -popupopts]]
                   [opt [arg -popupargs]]
                   [opt [arg {-lookup f}]]
                   [opt [arg {-qmark t}]]
                   [opt [arg {-track f}]]
                   [opt [arg {-caller f}]]
                   [opt [arg -ignore]]
                   [opt [arg {-disable f}]]
                   [opt args]

[para]
[item] [cmd ossweb::html::js_url] [arg url] [opt args]

[para]
[item] [cmd ossweb::html::proxy_url] [arg url] [opt args]

[para]
[item] [cmd ossweb::html::link] [opt [arg -query]]
                   [opt [arg -url]]
                   [opt [arg -app_name]]
                   [opt [arg -project_name]]
                   [opt [arg -page_name]]
                   [opt [arg -text]]
                   [opt [arg -html]]
                   [opt [arg -image]]
                   [opt [arg -path]]
                   [opt [arg -align]]
                   [opt [arg -css]]
                   [opt [arg -alt]]
                   [opt [arg {-width 16}]]
                   [opt [arg {-height 16}]]
                   [opt [arg {-class osswebLink}]]
                   [opt [arg {-host f}]]
                   [opt [arg -window]]
                   [opt [arg -winopts]]
                   [opt [arg -winargs]]
                   [opt [arg -confirm]]
                   [opt [arg -confirmtext]]
                   [opt [arg -imgname]]
                   [opt [arg -vspace]]
                   [opt [arg -opacity]]
                   [opt [arg -hspace]]
                   [opt [arg -title]]
                   [opt [arg {-disable f}]]
                   [opt [arg -name]]
                   [opt [arg {-href t}]]
                   [opt [arg -hash]]
                   [opt [arg {-proto "http://"}]]
                   [opt [arg -color]]
                   [opt [arg -onClick]]
                   [opt [arg -status]]
                   [opt [arg {-ignore f}]]
                   [opt [arg {-qmark t}]]
                   [opt [arg -list]]
                   [opt [arg -style]]
                   [opt [arg -mouseover]]
                   [opt [arg -onMouseOver]]
                   [opt [arg -onMouseOut]]
                   [opt [arg {-popup f}]]
                   [opt [arg -popupdnd]]
                   [opt [arg -popupsync]]
                   [opt [arg -popupname]]
                   [opt [arg -popupshow]]
                   [opt [arg -popupdata]]
                   [opt [arg -popupdataobj]]
                   [opt [arg -popuptop]]
                   [opt [arg -popupleft]]
                   [opt [arg -popupwidth]]
                   [opt [arg -popupheight]]
                   [opt [arg -popupbgcolor]]
                   [opt [arg -popupborder]]
                   [opt [arg -popupopts]]
                   [opt [arg -popupargs]]
                   [opt [arg -popupover]]
                   [opt [arg -popupoveropts]]
                   [opt [arg -acl]]
                   [opt [arg {-caller f}]]
                   [opt [arg {-track f}]]
                   [opt [arg {-lookup f}]]
                   [opt [arg {-loading f}]]
                   [opt [arg -windata]]
                   [opt [arg -id]]
                   [opt args]

[para]
[item] [cmd ossweb::html::help_link] [arg title]
                   [opt [arg -image]]
                   [opt [arg {-project_name unknown}]]
                   [opt [arg {-app_name unknown}]]
                   [opt [arg {-page_name unknown}]]
                   [opt [arg {-cmd_name unknown}]]
                   [opt [arg {-ctx_name unknown}]]

[para]
[item] [cmd ossweb::html::title] [arg title]

[para]
[item] [cmd ossweb::html::form_title] [arg title]

[para]
[item] [cmd ossweb::html::font] [opt [arg -type]]
                   [opt [arg -style]]
                   [opt [arg -html]]
                   [opt [arg -class]]
                   [opt [arg -color]]
                   [opt [arg -face]]
                   [opt [arg -size]]
                   [opt [arg {-close 1}]]
                   [arg msg]

[para]
[item] [cmd ossweb::html::image] [arg img]
                   [opt [arg -path]]
                   [opt [arg -alt]]
                   [opt [arg -vspace]]
                   [opt [arg -hspace]]
                   [opt [arg {-border 0}]]
                   [opt [arg -width]]
                   [opt [arg -height]]
                   [opt [arg -align]]
                   [opt [arg -html]]
                   [opt [arg -name]]
                   [opt [arg -style]]
                   [opt [arg -opacity]]
                   [opt [arg -id]]
                   [opt [arg -title]]

[para]
[item] [cmd ossweb::html::quote] [arg html]

[para]
[item] [cmd ossweb::html::select] [arg name] [arg options] [arg values] [opt [arg attributes]]

[para]
[item] [cmd ossweb::html::refresh] [arg interval] [opt [arg -url]]

[para]
[item] [cmd ossweb::html::play_sound] [arg sound]

[para]
[item] [cmd ossweb::html::popup_object] [arg id] [arg text]

[para]
[item] [cmd ossweb::html::popup_handlers] [arg id]
                   [opt [arg {-type popup}]]
                   [opt [arg -popupopts]]
                   [opt [arg -onMouseOver]]
                   [opt [arg -onMouseOut]]
                   [opt [arg -text]]

[para]
[item] [cmd ossweb::html::include] [arg name]
                   [opt [arg {-return f}]]
                   [opt [arg {-type js}]]
                   [opt [arg -data]]
                   [opt [arg {-basic f}]]
                   [opt [arg -plugins]]
                   [opt [arg -styles]]
                   [opt [arg {-mode head}]]
                   [opt [arg -host]]

[para]
[item] [cmd ossweb::html::combobox_menu] [arg name] [arg options]
                   [opt [arg {-iframe f}]]
                   [opt [arg -html]]
                   [opt [arg -separator]]
                   [opt [arg {-class osswebCombobox}]]
                   [opt [arg -class:table]]
                   [opt [arg -onKeyUp]]
                   [opt [arg -onChange]]
                   [opt [arg {-onClick formComboboxSet}]]

[para]
[item] [cmd ossweb::html::dropdown_menu] [arg name] [arg title] [arg options]
                   [opt [arg {-iframe t}]]
                   [opt [arg -html]]
                   [opt [arg {-image down5.gif}]]
                   [opt [arg -separator]]
                   [opt [arg {-url "javascript:;"}]]
                   [opt [arg -onClick]]
                   [opt [arg -onChange]]
                   [opt [arg {-class osswebDropdown}]]
                   [opt [arg -class:table]]
                   [opt [arg -class:title]]

[para]
[item] [cmd ossweb::html::popup_menu] [arg name] [arg options]
                   [opt [arg -html]]
                   [opt [arg -separator]]
                   [opt [arg {-class osswebPopup}]]
                   [opt [arg -class:table]]

[para]
[item] [cmd ossweb::html::textwidth] [arg text] [arg size]

[para]
[item] [cmd ossweb::html::menu] [arg name]
                   [opt [arg -project]]
                   [opt [arg {-all f}]]
                   [opt [arg {-session f}]]
                   [opt [arg -level]]
                   [opt [arg {-tree t}]]
                   [opt [arg {-icons t}]]

[para]
[item] [cmd ossweb::html::menu::js] [arg name] [arg color] [arg color1] [arg x] [arg y] [arg height]
                   [opt [arg {-font_size 12}]]
                   [opt [arg {-show_images 1}]]
                   [opt [arg {-spacing 1}]]

[para]
[item] [cmd ossweb::html::menu::admin]
                   [opt [arg {-ignore {^help$|index|reftable}}]]
                   [opt [arg {-table f}]]
                   [opt [arg {-class osswebMenuAdmin}]]

[para]
[item] [cmd ossweb::html::files] [arg path] [arg match] [opt [arg subdir]]

[para]
[item] [cmd ossweb::html::images]

[para]
[item] [cmd ossweb::html::sounds]

[para]
[item] [cmd ossweb::html::escape] [arg url] [opt [arg {-part path}]]

[list_end]

[para]

[subsection {Template Procs}]

[list_begin itemized]

[item] [cmd ossweb::adp::File] [opt [arg file]]

[para]
[item] [cmd ossweb::adp::Length]

[para]
[item] [cmd ossweb::adp::DirName]

[para]
[item] [cmd ossweb::adp::Include] [arg file]

[para]
[item] [cmd ossweb::adp::Level] [opt [arg level]]

[para]
[item] [cmd ossweb::adp::Trim] [opt [arg trim]]

[para]
[item] [cmd ossweb::adp::ContentType] [opt [arg type]]

[para]
[item] [cmd ossweb::adp::Reset]

[para]
[item] [cmd ossweb::adp::Write] [arg text]

[para]
[item] [cmd ossweb::adp::Buffer] [arg what] [opt [arg name]] [opt [arg value]]

[para]
[item] [cmd ossweb::adp::Cookie]

[para]
[item] [cmd ossweb::adp::Cache] [arg type] [arg path]

[para]
[item] [cmd ossweb::adp::Execute] [arg path] [opt [arg params]]

[para]
[item] [cmd ossweb::adp::Evaluate] [arg sdata] [opt [arg slevel]] [opt [arg {smode 1}]]

[para]
[item] [cmd ossweb::adp::Exit] [opt [arg {result -1}]]

[para]
[item] [cmd ossweb::adp::Compile] [arg chunk] [opt [arg {mode 1}]] [opt [arg {save 0}]]

[para]
[item] [cmd ossweb::adp::Parse] [arg chunk]

[para]
[item] [cmd ossweb::adp::AppendData] [arg text]]

[para]
[item] [cmd ossweb::adp::AppendCode] [arg code]]

[para]
[item] [cmd ossweb::tag::info] [arg type]

[para]
[item] [cmd ossweb::tag::create] [arg name] [arg args] [arg body]

[list_end]

[para]

[subsection {Custom Tags}]

[list_begin itemized]

[item] [cmd <ossweb:header>]

[para]
[item] [cmd <ossweb:footer>]

[para]
[item] [cmd <ossweb:msg>]

[para]
[item] [cmd <ossweb:title>]

[para]
[item] [cmd <ossweb:url>]

[para]
[item] [cmd <ossweb:link>]

[para]
[item] [cmd <border>]

[para]
[item] [cmd <helpbutton>]

[para]
[item] [cmd <helpimage>]

[para]
[item] [cmd <helptitle>]

[para]
[item] [cmd <tcl>]

[para]
[item] [cmd <join>]

[para]
[item] [cmd <decode>]

[para]
[item] [cmd <master>]

[para]
[item] [cmd <slave>]

[para]
[item] [cmd <template>]

[para]
[item] [cmd <include>]

[para]
[item] [cmd <grid>]

[para]
[item] [cmd <multirow>]

[para]
[item] [cmd <group>]

[para]
[item] [cmd <list>]

[para]
[item] [cmd <multilist>]

[para]
[item] [cmd <foreach>]

[para]
[item] [cmd <return>]

[para]
[item] [cmd <continue>]

[para]
[item] [cmd <exit>]

[para]
[item] [cmd <if>]

[para]
[item] [cmd <else>]

[para]
[item] [cmd <case>]

[para]
[item] [cmd <when>]

[para]
[item] [cmd <formtab>]

[para]
[item] [cmd <formerror>]

[para]
[item] [cmd <formwidget>]

[para]
[item] [cmd <formlabel>]

[para]
[item] [cmd <formhelp>]

[para]
[item] [cmd <formgroup>]

[para]
[item] [cmd <formtemplate>]

[para]
[item] [cmd <formwidgets>]

[para]
[item] [cmd <row>]

[para]
[item] [cmd <rowfirst>]

[para]
[item] [cmd <rowsection>]

[para]
[item] [cmd <rowlast>]

[para]
[item] [cmd <rowtitle>]

[para]
[item] [cmd <multipage>]

[para]
[item] [cmd <calendar>]

[list_end]

[para]

[subsection {File Storage Procs}]

[list_begin itemized]

[item] [cmd ossweb::file::register_download_proc] [arg module] [arg proc_name]

[para]
[item] [cmd ossweb::file::register_download_check] [arg module] [arg proc_name]

[para]
[item] [cmd ossweb::file::root]

[para]
[item] [cmd ossweb::file::url] [arg module] [arg file_name] [opt [arg args]]

[para]
[item] [cmd ossweb::file::link] [arg module] [arg file_name]
                   [opt [arg -html]]
                   [opt [arg -name]]
                   [opt [arg -text]]
                   [opt [arg -status]]
                   [opt [arg {-class osswebLink}]]
                   [opt [arg -image]]
                   [opt [arg -confirm]]
                   [opt [arg -window]]
                   [opt [arg -winopts]]
                   [opt [arg -align]]
                   [opt [arg -alt]]
                   [opt [arg -path]]
                   [opt [arg -proto]]
                   [opt [arg {-host f}]]
                   [opt [arg {-width 16}]]
                   [opt [arg {-height 16}]]
                   [opt args]

[para]
[item] [cmd ossweb::file::upload] [arg name]
                   [opt [arg -path]]
                   [opt [arg {-unique f}]]
                   [opt [arg -newname]]
                   [opt [arg -oldname]]
                   [opt [arg -save]]
                   [opt [arg {-mode storage}]]
                   [opt [arg {-nonempty f}]]
                   [opt [arg {-debug f}]]

[para]
[item] [cmd ossweb::file::save] [arg name] [arg value]
                   [opt [arg -path]]
                   [opt [arg {-unique f}]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::file::rename] [arg from] [arg name]
                   [opt [arg -path]]
                   [opt [arg {-unique f}]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::file::name] [arg name] [opt [arg property]]

[para]
[item] [cmd ossweb::file::getname] [arg name]
                   [opt [arg -path]]
                   [opt [arg {-unique f}]]
                   [opt [arg {-create f}]]
                   [opt [arg -user_id]]
                   [opt [arg {-mode storage}]]

[para]
[item] [cmd ossweb::file::delete] [arg name]
                   [opt [arg -path]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::file::stat] [arg name] [arg varname]
                   [opt [arg -path]]
                   [opt [arg -user_id]]
                   [opt [arg {-mode storage}]]

[para]
[item] [cmd ossweb::file::size] [arg name]
                   [opt [arg -path]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::file::mtime] [arg name]
                   [opt [arg -path]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::file::exists] [arg name]
                   [opt [arg -path]]
                   [opt [arg -user_id]]

[para]
[item] [cmd ossweb::file::image_exists] [arg id] [arg path] [opt [arg prefix]]

[para]
[item] [cmd ossweb::file::check_acl] [arg name] [arg path] [opt [arg user_id]]

[para]
[item] [cmd ossweb::file::open] [arg name]
                   [opt [arg -path]]
                   [opt [arg {-mode r}]]

[para]
[item] [cmd ossweb::file::list]
                   [opt [arg -path]]
                   [opt [arg -user_id]]
                   [opt [arg -types]]
                   [opt [arg {-filter *}]]
                   [opt [arg {-dirname t}]]
                   [opt [arg -sort]]
                   [opt [arg {-struct f}]]
                   [opt [arg {-desc f}]]

[para]
[item] [cmd ossweb::file::return] [arg name]
                   [opt [arg -path]]
                   [opt [arg -type]]
                   [opt [arg {-mode storage}]]

[list_end]

[para]

[subsection {Utility Procs}]

[list_begin itemized]

[item] [cmd ossweb::util::fmt] [arg value] [arg format] [opt [arg default]]

[para]
[item] [cmd ossweb::util::lmax] [arg list]

[para]
[item] [cmd ossweb::util::lmin] [arg list]

[para]
[item] [cmd ossweb::util::lshuffle] [arg list]

[para]
[item] [cmd ossweb::util::clock] [arg seconds]

[para]
[item] [cmd ossweb::util::size] [arg size]

[para]
[item] [cmd ossweb::util::wrap_text] [arg text] [opt [arg {-size 80}]] [opt [arg {-break}]]

[para]
[item] [cmd ossweb::util::money] [arg value]

[para]
[item] [cmd ossweb::util::gethome] [opt [arg name]]

[para]
[item] [cmd ossweb::util::open] [arg host] [arg port] [opt [arg {timeout 30}]]

[para]
[item] [cmd ossweb::util::gets] [arg fd] [opt [arg {timeout 30}]]

[para]
[item] [cmd ossweb::util::puts] [arg fd] [arg line] [opt [arg {timeout 30}]]

[para]
[item] [cmd ossweb::util::number] [arg num] [opt [arg {default 0}]]

[para]
[item] [cmd ossweb::util::email_template] [opt [arg -level]] [opt args]

[para]
[item] [cmd ossweb::util::chart]
                   [opt [arg -title]]
                   [opt [arg {-type line}]]
                   [opt [arg {-module gdchart}]]
                   [opt [arg -image]]
                   [opt [arg {-return f}]]
                   [opt [arg -data]]
                   [opt [arg -labels]]
                   [opt [arg -colors]]
                   [opt [arg {-xaxis Time}]]
                   [opt [arg {-xaxisangle 0}]]
                   [opt [arg {-yaxis Data}]]
                   [opt [arg -ylabelfmt]]
                   [opt [arg {-3d f}]]
                   [opt [arg {-layers f}]]
                   [opt [arg {-grid 0}]]
                   [opt [arg {-gridcolor 0x3c4e5e}]]
                   [opt [arg {-gridontop 1}]]
                   [opt [arg {-border 1}]]
                   [opt [arg {-shelf 1}]]
                   [opt [arg {-bgcolor 0xf2f5fa}]]
                   [opt [arg {-linecolor 0x000000}]]
                   [opt [arg {-width 500}]]
                   [opt [arg {-height 400}]]
                   [opt [arg {-legend bottom}]]
                   [opt [arg {-legendx 10}]]
                   [opt [arg {-legendy 350}]]
                   [opt [arg {-plotx 60}]]
                   [opt [arg {-ploty 30}]]
                   [opt [arg {-plotwidth 420}]]
                   [opt [arg {-plotheight 300}]]
                   [opt [arg {-plotcolor 0x000000}]]
                   [opt [arg {-barwidth 75}]]

[list_end]

[para]

[subsection {Scheduling Procs}]

[list_begin itemized]

[item] [cmd ossweb::schedule::init] [opt [arg task_id]]

[para]
[item] [cmd ossweb::schedule::job] [arg args]

[para]
[item] [cmd ossweb::schedule::run] [arg proc_name] [opt [arg -weekdays]] [opt [arg -monthdays]]

[para]
[item] [cmd ossweb::schedule::tsearch] [opt [arg -types]]
                                      [opt [arg {-iterations 1}]]
                                      [opt [arg {-sleep 5}]]
                                      [opt [arg -empty]]
                                      [opt [arg {-hours {09 12 15 18 21}}]]

[list_end]

[para]

[subsection {Admin Procs}]

[list_begin itemized]

[item] [cmd ossweb::admin::password] [arg user] [arg password]

[para]
[item] [cmd ossweb::admin::prefs] [arg cmd]
                   [opt [arg -obj_id]]
                   [opt [arg {-obj_type U}]]
                   [opt args]

[para]
[item] [cmd ossweb::admin::create_user] [opt [arg -groups]]
                   [opt [arg -group_names]]
                   [opt args]

[para]
[item] [cmd ossweb::admin::update_user] [opt [arg -user_id]]
                   [opt [arg {-flush t}]]
                   [opt [arg {-transaction t}]]
                   [opt [arg -groups]]
                   [opt [arg -group_names]]
                   [opt [arg {-prefs f}]]
                   [opt args]

[para]
[item] [cmd ossweb::admin::flush_user] [opt [arg user_id]]

[para]
[item] [cmd ossweb::admin::delete_user] [arg user_id]

[para]
[item] [cmd ossweb::admin::update_session] [opt [arg -user_id]]
                   [opt [arg {-flush f}]]
                   [opt [arg -interval]]
                   [opt args]

[para]
[item] [cmd ossweb::admin::belong_group] [opt [arg -user_id]]
                   [opt [arg -group_id]]
                   [opt [arg -group_name]]

[para]
[item] [cmd ossweb::admin::login] [arg user_name] [arg password]
                   [opt [arg {-verify f}]]
                   [opt [arg -user_id]]
                   [opt [arg {-redirect t}]]
                   [opt [arg {-callbacks t}]]
                   [opt args]

[para]
[item] [cmd ossweb::admin::logout] [opt [arg {-callbacks t}]]
                   [opt [arg {-redirect t}]]

[para]
[item] [cmd ossweb::admin::reboot] [opt [arg {interval 30}]]

[para]
[item] [cmd ossweb::admin::read_popup] [opt [arg user_id]]

[para]
[item] [cmd ossweb::admin::send_popup] [opt [arg -user_id]]
                   [arg msg]

[para]
[item] [cmd ossweb::control::prefs] [arg type] [opt args]

[para]
[item] [cmd ossweb::control::user] [arg type] [arg user_id] [opt args]

[para]
[item] [cmd ossweb::control::user::group] [arg type] [arg user_id] [opt args]

[para]
[item] [cmd ossweb::cluster::send] [arg host] [arg cmd] [arg name]
                   [opt [arg {-debug f}]]
                   [opt [arg -cache]]
                   [opt [arg {-noreply f}]]
                   [opt [arg -timeout]]
                   [opt [arg -value]]
                   [opt [arg -callback]]

[para]
[item] [cmd ossweb::cluster] [arg cmd] [arg name]
                   [opt [arg -host]]
                   [opt [arg {-debug f}]]
                   [opt [arg -value]]
                   [opt [arg -cache]]
                   [opt [arg {-noreply f}]]
                   [opt [arg {-self f}]]
                   [opt [arg -timeout]]
                   [opt [arg -callback]]

[para]
[item] [cmd ossweb::cluster::master]

[para]
[item] [cmd ossweb::resource::lock] [arg rcs_type] [arg rcs_name]
                   [opt [arg -rcs_start]]
                   [opt [arg -rcs_end]]
                   [opt [arg -rcs_data]]
                   [opt [arg -rcs_user]]

[para]
[item] [cmd ossweb::resource::trylock] [arg rcs_type] [arg rcs_name]
                   [opt [arg -rcs_start]]
                   [opt [arg -rcs_end]]
                   [opt [arg -rcs_data]]
                   [opt [arg -rcs_user]]

[para]
[item] [cmd ossweb::resource::unlock] [arg rcs_type] [arg rcs_name]
                   [opt [arg -rcs_start]]
                   [opt [arg -rcs_end]]
                   [opt [arg -rcs_data]]
                   [opt [arg -rcs_user]]

[para]
[item] [cmd ossweb::resource::check] [arg rcs_type] [arg rcs_name]
                   [opt [arg -rcs_start]]
                   [opt [arg -rcs_end]]
                   [opt [arg -rcs_data]]
                   [opt [arg -rcs_user]]

[list_end]

[para]

[subsection {Lookup Procs}]

[list_begin itemized]

[item] [cmd ossweb::lookup::mode]

[para]
[item] [cmd ossweb::lookup::master]

[para]
[item] [cmd ossweb::lookup::url] [arg args]

[para]
[item] [cmd ossweb::lookup::link] [arg args]

[para]
[item] [cmd ossweb::lookup::property] [arg name]

[para]
[item] [cmd ossweb::lookup::row] [arg name]
                   [opt [arg -id]]
                   [opt [arg {-return f}]]
                   [opt [arg {-script f}]]
                   [opt [arg {-row_name row}]]
                   [opt [arg -field]]

[para]
[item] [cmd ossweb::lookup::form] [arg form]
                   [opt [arg {-select f}]]
                   [opt [arg {-close f}]]

[para]
[item] [cmd ossweb::lookup::start] [arg return]
                   [opt [arg -page_name]]
                   [opt [arg -cmd_name]]
                   [opt [arg -ctx_name]]
                   [opt [arg -app_name]]
                   [opt [arg -project_name]]
                   [opt [arg {-mode 1}]]
                   [opt [arg -div]]
                   [opt [arg -proc]]

[para]
[item] [cmd ossweb::lookup::stop]
                   [opt [arg {-level 1}]]
                   [opt [arg -sql]]
                   [opt [arg -row]]
                   [opt [arg {-return "-cmd_name view"}]]

[para]
[item] [cmd ossweb::lookup::exec] [opt [arg -sql]]

[para]
[item] [cmd ossweb::lookup::onereturn] [arg name] [arg column]
                   [opt [arg {-return t}]]
                   [opt [arg {-row_name row}]]
                   [opt [arg -eval]]

[list_end]

[include keywords.man]

[manpage_end]

